#!/usr/bin/env python

"""
Quark release tool. Because quark involves a variety of different
support packages for backend languages, the release process involves
dealing with a lot of different packaging tools and environments. This
utility captures all this in a single place.

Usage:
  release [--dry] cleanup
  release [--dry] prepare-release --prod [<version>] [--doc=<version>]
  release [--dry] push-release
  release [--dry] version [--dev | --prod] [<version>] [--doc=<version>]
  release [--dry | --cicd] push-pkgs
  release [--dry | --cicd] push-docs

  Options:
    --dry                  Dry run.
    --cicd                 Do not ask for challenge.

    --dev                  Change to development packages.
    --prod                 Change to production packages.

    --doc <version>        Documentation version.
"""

import json, os, random, re, subprocess, tempfile, urllib2
from docopt import docopt
from collections import OrderedDict
try:  # py3
    from shlex import quote
except ImportError:  # py2
    from pipes import quote

__dir__ = None
__dry__ = False
__cicd__ = False

def base(name=None):
    global __dir__
    if __dir__ is None:
        __dir__ = call("git", "rev-parse", "--show-toplevel", dry=False).strip()
    if name:
        return os.path.join(__dir__, name)
    else:
        return __dir__


def _do(method, *command, **kwargs):
    dry = kwargs.pop("dry", __dry__)
    cmd =  " ".join(map(quote,command))
    if dry:
        print "$  #", cmd, kwargs
        return
    print "$   ", cmd, kwargs
    return method(command, **kwargs)

def call(*command, **kwargs):
    """Execute the supplied command and return the output."""
    return _do(subprocess.check_output, *command, **kwargs)

def run(*command, **kwargs):
    """Execute the supplied command."""
    _do(subprocess.check_call, *command, **kwargs)

metadata = {}
with open(base("quarkc/_metadata.py")) as fp:
    exec(fp.read(), metadata)
with open(base("docs/conf.py")) as fp:
    for line in fp:
        if line.startswith("__doc_version__"):
            exec(line, metadata)

## utilities

class ReleaseError(Exception):
    """An anticipated error."""

def check(*commands):
    """Check whether the supplied commands are available."""
    cmd = ["which"] + list(commands)
    try:
        subprocess.check_output(cmd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError, e:
        raise ReleaseError("Please install and configure missing prereqs: %s\n\n%s" %
                           (", ".join(commands), e.output))


def pipcheck(*packages):
    missing = []
    for pkg in packages:
        try:
            subprocess.check_output(["pip", "show", pkg], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError, e:
            missing.append(pkg)
    if missing:
        raise ReleaseError("Please install missing python packages: %s" % ", ".join(missing))

def update_json(name, **kwargs):
    """Update a json file with supplied overrides."""
    with open(name, "r") as fd:
        original = fd.read()
        obj = json.loads(original, object_pairs_hook=OrderedDict)
        obj.update(kwargs)
    updated = json.dumps(obj, indent=4, separators=(',', ': ')) + "\n"
    if updated != original:
        print "Updating json %s: %s" % (name, kwargs)
        if __dry__: return
        with open(name, "w") as fd:
            fd.write(updated)

def substitute(line, vars):
    """
    Substitute a line of python code declaring a variable of the form
    __<name>__ = <value>.  The name must be at the beginning of the
    line in order to match.
    """
    for key in vars:
        varname = "__%s__" % key
        if line.startswith(varname):
            return "%s = %s\n" % (varname, repr(vars[key]))
    else:
        return line

def update_python(name, **kwargs):
    """Update a python file with supplied overrides."""
    lines = []
    orig_lines = []
    with open(name, "r") as fd:
        for line in fd:
            orig_lines.append(line)
            lines.append(substitute(line, kwargs))
    updated = "".join(lines)
    original = "".join(orig_lines)
    if updated != original:
        print "Updating python %s: %s" % (name, kwargs)
        if __dry__: return True
        with open(name, "w") as fd:
            fd.write(updated)
        return True
    else:
        return False

def push_wheel(path):
    dest = tempfile.mkdtemp()
    run("python", "setup.py", "-q", "clean", "bdist_wheel", "-d", dest, cwd=base(path), dry=False)
    for name in os.listdir(dest):
        run("twine", "upload", "--skip-existing", os.path.join(dest, name), cwd=base())

## version update logic

def quark_version(version, doc_version, dev):
    if dev:
        title = "datawire-quarkdev"
    else:
        title = "datawire-quark"

    subs = {"title": title,
            "version": version,
            "doc_version": doc_version}

    updated = []
    for fname in ("quarkc/_metadata.py", "docs/conf.py"):
        if update_python(base(fname), **subs):
            updated.append(fname)

    return title, updated

def is_dev():
    return metadata["__title__"].endswith("dev")

## push logic

def push_quark():
    push_wheel(base())

## subcommands

def show_metadata():
    names = metadata["__all__"] + ["__doc_version__"]
    width = max(map(lambda n: len(n.strip("_")), names))
    for name in names:
        print "%*s: %s" % (width, name.strip("_"), metadata[name])

def version(args):
    if not (args["--dev"] or args["--prod"] or args["--doc"] or args["<version>"]):
        return show_metadata()

    if args["--dev"]:
        dev = True
    elif args["--prod"]:
        dev = False
    else:
        dev = is_dev()

    ver = args["<version>"]
    
    if ver:
        doc_default = "1"
    else:
        ver = metadata["__version__"]
        doc_default = metadata["__doc_version__"]

    docver = args["--doc"] or doc_default

    title, updated = quark_version(ver, docver, dev)
    dry = __dry__ or dev
    for fname in updated:
        run("git", "add", fname, cwd=base(), dry=dry)
    run("git", "commit", "-m", "Changed version to %s, %s (doc %s). [skip-ci]" % (title, ver, docver),
        cwd=base(), dry=dry)

def randstr():
    result = ""
    for i in range(4):
        result += chr(ord('a') + random.randint(0, 25))
    return result

def challenge():
    if __cicd__:
        print "No confirmation required, --cicd was provided"
        return True
    chal = randstr()
    text = raw_input('Please type "%s" to confirm: ' % chal)
    return text == chal

release_document_template = """
README file: https://github.com/datawire/quark/blob/%(tag)s/README.md

Full documentation: http://datawire.github.io/quark/%(short)s/index.html

We would appreciate your feedback! Please file issues here on Github.

For more information get in touch by email at hello@datawire.io or by Twitter at @datawireio.
"""

def make_github_release(tag, commitish=""):
    # Assumes that the tag already exists or the commit-ish is provided.
    major, minor, _ = tag.split(".", 2)
    short = major + "." + minor
    name = "Quark %s" % tag
    body = release_document_template.strip() % locals()
    post_data = dict(tag_name=tag, target_commitish=commitish, draft=False, prerelease=False, name=name, body=body)

    # Visit https://github.com/settings/tokens
    # Select "Generate new token"
    # Only required scope is "public_repo"
    # Paste resulting token (40 chars as of Jan 2016) into:
    token_path = "~/.github_public_repo_token"
    try:
        token = open(os.path.expanduser(token_path)).read().strip()
    except IOError as exc:
        print "Github release failed: Could not find Github auth token in %s: %s" % (token_path, exc)
        return False

    url = "https://api.github.com/repos/datawire/quark/releases?access_token=%(token)s" % locals()
    try:
        urllib2.urlopen(url, json.dumps(post_data))
        return True
    except Exception as exc:
        print "Github release failed: %s" % exc

    return False

def push_pkgs(args):
    print "You are about to push the following package live:"
    print
    print "    %s: %s" % (metadata["__title__"], metadata["__version__"])
    print
    if challenge():
        print "Pushing"
        push_quark()
    else:
        print "Canceled"

def push_docs(args):
    version = metadata["__version__"]
    short = ".".join(version.split(".")[:2])
    docver = metadata["__doc_version__"]
    if is_dev():
        docdest = os.path.join("dev", short)
    else:
        docdest = short
    print "You are about to push the documentation live:"
    print
    print "    version: %s" % version
    print "        doc: %s" % docver
    print "       dest: %s" % docdest
    print
    if challenge():
        print "Pushing docs"
        dest = tempfile.mkdtemp()
        run("git", "clone", "-b", "gh-pages", "--depth", "5",
            call("git", "config", "--get", "remote.origin.url", dry=False).strip(),
            dest)
        run("touch", ".nojekyll", cwd=dest)
        run("git", "rm", "-r", "--ignore-unmatch", docdest, cwd=dest)
        run("sphinx-build", "-q", "docs", os.path.join(dest, docdest), cwd=base())
        run(base("docs/substitute.sh"), dest)
        run("git", "add", ".", cwd=dest)
        run("git", "commit", "-m", "Documentation update %s-%s." % (version, docver), cwd=dest)
        run("git", "push", "origin", "gh-pages", cwd=dest)
        print "Documentation is pushed."
    else:
        print "Canceled"


RELEASE_BRANCH="release-in-progress"

def in_release():
    return call("git", "branch", "--list", RELEASE_BRANCH+"*", dry=False).splitlines()

def prepare_release(args):
    assert args["--prod"]
    releasing = in_release()
    if releasing:
        raise ReleaseError("Release appears to be in progress, found %s\n\n%s" % (
            releasing,"Investigate and run ./release cleanup"))
    run("git", "checkout",  "develop")
    run("git", "pull")
    next_ver = call("scripts/compute-next-version", dry=False).strip()
    actual_tag = call("git", "describe", dry=False).strip()
    expected_tag = "dev-%s" % next_ver
    if expected_tag != actual_tag:
        raise ReleaseError("Develop branch is not stable, got '%s' expected '%s'\n\n%s" % (
            actual_tag, expected_tag,
            "Aborting. Please wait for CI to catch up and retry later"));
    run("git", "checkout", "-b", RELEASE_BRANCH)
    ver = args["<version>"]
    if not ver:
        print "No version override supplied, using automatic version %s" % next_ver
        ver = args["<version>"] = next_ver
    version(args)
    release_tag = "v%s" % ver
    run("git", "tag", "-s", "-m", "Release of %s" % (ver, ), release_tag)

## main

def main(args):
    global __dry__, __cicd__
    __dry__ = args["--dry"]
    __cicd__ = args["--cicd"]
    check("pip", "twine", "git")
    pipcheck("wheel", "sphinx", "sphinx-better-theme")
    if args["version"]:
        version(args)
    elif args["push-pkgs"]:
        push_pkgs(args)
    elif args["push-docs"]:
        push_docs(args)
    elif args["prepare-release"]:
        prepare_release(args)
    elif args["cleanup"]:
        cleanup(args)
    elif args["push-release"]:
        push_release(args)
    else:
        assert False

def call_main(args):
    try:
        return main(args)
    except ReleaseError, e:
        return e

if __name__ == "__main__":
    exit(call_main(docopt(__doc__)))
