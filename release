#!/usr/bin/env python

"""
Quark release tool. Because quark involves a variety of different
support packages for backend languages, the release process involves
dealing with a lot of different packaging tools and environments. This
utility captures all this in a single place.

Usage:
  release [--dry] version [<version>] [--dev] [--runtime-only] [--quark=<ver>] [--java=<ver>] [--js=<ver>] [--py=<ver>] [--doc=<ver>]
  release [--dry] dev
  release [--dry] prod
  release [--dry] push [--runtime-only]
  release [--dry] docs
  release [--dry] metadata

  Options:
    --dry                  Dry run.

    --dev                  Apply development suffix to all versions.
    --runtime-only         Apply command to runtime only.

    --quark <version>      Quark version.
    --java <version>       Java runtime version.
    --js <version>         Javascript runtime version.
    --py <version>         Python runtime version.
    --doc <version>        Documentation version.
"""

import json, os, random, re, subprocess, tempfile, urllib2
from docopt import docopt
from collections import OrderedDict

__dir__ = os.path.dirname(__file__)
__dry__ = False

def base(name=None):
    if name:
        return os.path.join(__dir__, name)
    else:
        return __dir__

metadata = {}
with open(base("quark/_metadata.py")) as fp:
    exec(fp.read(), metadata)
with open(base("docs/conf.py")) as fp:
    for line in fp:
        if line.startswith("__doc_version__"):
            exec(line, metadata)

## utilities

class ReleaseError(Exception):
    """An anticipated error."""

def check(*commands):
    """Check whether the supplied commands are available."""
    cmd = ["which"] + list(commands)
    try:
        subprocess.check_output(cmd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError, e:
        raise ReleaseError("Please install and configure missing prereqs: %s\n\n%s" %
                           (", ".join(commands), e.output))


def pipcheck(*packages):
    missing = []
    for pkg in packages:
        try:
            subprocess.check_output(["pip", "show", pkg], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError, e:
            missing.append(pkg)
    if missing:
        raise ReleaseError("Please install missing python packages: %s" % ", ".join(missing))

def run(*command, **kwargs):
    """Execute the supplied command."""
    dry = kwargs.pop("dry", __dry__)
    print " ".join(command), kwargs
    if dry: return
    subprocess.check_call(command, **kwargs)

def call(*command, **kwargs):
    """Execute the supplied command and return the output."""
    dry = kwargs.pop("dry", __dry__)
    print " ".join(command), kwargs
    if dry: return
    return subprocess.check_output(command, **kwargs)

def update_json(name, **kwargs):
    """Update a json file with supplied overrides."""
    with open(name, "r") as fd:
        original = fd.read()
        obj = json.loads(original, object_pairs_hook=OrderedDict)
        obj.update(kwargs)
    updated = json.dumps(obj, indent=4, separators=(',', ': ')) + "\n"
    if updated != original:
        print "Updating json %s: %s" % (name, kwargs)
        if __dry__: return
        with open(name, "w") as fd:
            fd.write(updated)

def substitute(line, vars):
    """
    Substitute a line of python code declaring a variable of the form
    __<name>__ = <value>.  The name must be at the beginning of the
    line in order to match.
    """
    for key in vars:
        varname = "__%s__" % key
        if line.startswith(varname):
            return "%s = %s\n" % (varname, repr(vars[key]))
    else:
        return line

def update_python(name, **kwargs):
    """Update a python file with supplied overrides."""
    lines = []
    orig_lines = []
    with open(name, "r") as fd:
        for line in fd:
            orig_lines.append(line)
            lines.append(substitute(line, kwargs))
    updated = "".join(lines)
    original = "".join(orig_lines)
    if updated != original:
        print "Updating python %s: %s" % (name, kwargs)
        if __dry__: return
        with open(name, "w") as fd:
            fd.write(updated)

def update_package(name, dev):
    if dev:
        target = "quarkdev"
    else:
        target = "quark"

    lines = []
    orig_lines = []
    with open(name, "r") as fd:
        update_version = False
        for line in fd:
            orig_lines.append(line)
            if (('<artifactId>' in line and 'netty' in line) or
                ('setup(name=' in line) or
                ('"name":' in line) or
                ('require("' in line)):
                lines.append(line.replace("quarkdev", "quark").replace("quark", target))
            else:
                lines.append(line)

    updated = "".join(lines)
    original = "".join(orig_lines)
    if updated != original:
        print "Updating %s: %s" % (name, target)
        if __dry__: return
        with open(name, "w") as fd:
            fd.write(updated)

class Walker(object):

    def __init__(self, ext):
        self.ext = ext

    def __call__(self, result, dir, fnames):
        for f in fnames:
            if f.endswith(self.ext):
                result.append(os.path.join(dir, f))

def walk(dir, ext):
    result = []
    os.path.walk(dir, Walker(ext), result)
    return result

def update_packages(dev):
    files = [base(f) for f in ("setup.py", "runtime/python-threaded/setup.py",
                               "runtime/twisted/setup.py", "runtime/js-node/package.json")]
    files.extend(walk(base(), "pom.xml"))
    files.extend(walk(base("examples"), ".js"))
    for f in files:
        update_package(f, dev)

def push_wheel(path):
    dest = tempfile.mkdtemp()
    run("python", "setup.py", "-q", "clean", "bdist_wheel", "-d", dest, cwd=base(path), dry=False)
    for name in os.listdir(dest):
        run("twine", "upload", "--skip-existing", os.path.join(dest, name), cwd=base())

## version update logic

def quark_version(version):
    update_python(base("quark/_metadata.py"), version=version)
    update_python(base("docs/conf.py"), version=version)

def update_netty(name, version):
    with open(name, "r") as fd:
        orig_lines = []
        lines = []
        prev = ""
        for line in fd:
            orig_lines.append(line)
            if '<version>' in line and '<artifactId>' in prev and 'quark' in prev and 'netty' in prev:
                lines.append(re.sub('>.*<', '>%s<' % version, line))
            else:
                lines.append(line)
            prev = line

        updated = "".join(lines)
        original = "".join(orig_lines)
        if updated != original:
            print "Updating %s: %s" % (name, version)
            if __dry__: return
            with open(name, "w") as fd:
                fd.write(updated)

def java_version(version):
    run("mvn", "-q", "versions:set", "-DgenerateBackupPoms=false", "-DnewVersion=%s" % version,
        cwd=base())
    update_python(base("quark/_metadata.py"), java_runtime_version=version)
    for f in walk(base("examples"), "pom.xml"):
        update_netty(f, version)

def js_version(version):
    for name in ("runtime/js-core/package.json", "runtime/js-node/package.json"):
        update_json(base(name), version=version)
    update_python(base("quark/_metadata.py"), js_runtime_version=version)

def py_version(version):
    for name in ("runtime/python-core/quark_runtime.py", "runtime/twisted/quark_twisted_runtime.py",
                 "runtime/python-threaded/quark_threaded_runtime.py"):
        update_python(base(name), version=version)
    update_python(base("quark/_metadata.py"), py_runtime_version=version)

def doc_version(version):
    update_python(base("docs/conf.py"), doc_version=version)

## push logic

def push_java():
    run("mvn", "clean", "deploy", "-P", "release", cwd=base())
    run("mvn", "nexus-staging:release", cwd=base())

def push_js():
    for sfx in ("core", "node"):
        with open(base("runtime/js-%s/package.json" % sfx)) as fd:
            pkg = json.load(fd)
        info = call("npm", "info", pkg["name"], "--json", cwd=base(), dry=False)
        latest = json.loads(info)["dist-tags"]["latest"]
        if latest == metadata["__js_runtime_version__"]:
            print "Skipping javascript %s, version %s already pushed." % (sfx, latest)
        else:
            run("npm", "publish", base("runtime/js-%s" % sfx), cwd=base())

def push_py():
    for path in ("runtime/python-core", "runtime/twisted", "runtime/python-threaded"):
        push_wheel(base(path))

def push_quark():
    push_wheel(base())

## subcommands

ALIASES = {
    "--quark": "__version__",
    "--java": "__java_runtime_version__",
    "--js": "__js_runtime_version__",
    "--py": "__py_runtime_version__",
    "--doc": "__doc_version__"
}

def relver(args, component):
    if component == "--doc":
        return args[component] or metadata[ALIASES[component]]
    else:
        return args[component] or args["<version>"] or metadata[ALIASES[component]]

def is_dev(version):
    return version.endswith("-SNAPSHOT") or version.endswith(".dev0")

def devver(args, component):
    version = relver(args, component)
    if is_dev(version):
        return version
    elif component == "--doc":
        return version
    elif component in ("--quark", "--py"):
        return "%s.dev0" % version
    else:
        return "%s-SNAPSHOT" % version

def version(args):
    if args["--dev"]:
        getver = devver
    else:
        getver = relver

    if not args["--runtime-only"]:
        quark_version(getver(args, "--quark"))
    java_version(getver(args, "--java"))
    js_version(getver(args, "--js"))
    py_version(getver(args, "--py"))
    doc_version(getver(args, "--doc"))

VERSIONS = [("quark", metadata["__version__"]),
            ("java runtime", metadata["__java_runtime_version__"]),
            ("js runtime", metadata["__js_runtime_version__"]),
            ("py runtime", metadata["__py_runtime_version__"])]

def randstr():
    result = ""
    for i in range(4):
        result += chr(ord('a') + random.randint(0, 25))
    return result

def challenge():
    chal = randstr()
    text = raw_input('Please type "%s" to confirm: ' % chal)
    return text == chal

release_document_template = """
README file: https://github.com/datawire/quark/blob/%(tag)s/README.md

Full documentation: http://datawire.github.io/quark/%(short)s/index.html

We would appreciate your feedback! Please file issues here on Github.

For more information get in touch by email at hello@datawire.io or by Twitter at @datawireio.
"""

def make_github_release(tag, commitish=""):
    # Assumes that the tag already exists or the commit-ish is provided.
    major, minor, _ = tag.split(".", 2)
    short = major + "." + minor
    name = "Quark %s" % tag
    body = release_document_template.strip() % locals()
    post_data = dict(tag_name=tag, target_commitish=commitish, draft=False, prerelease=False, name=name, body=body)

    # Visit https://github.com/settings/tokens
    # Select "Generate new token"
    # Only required scope is "public_repo"
    # Paste resulting token (40 chars as of Jan 2016) into:
    token_path = "~/.github_public_repo_token"
    try:
        token = open(os.path.expanduser(token_path)).read().strip()
    except IOError as exc:
        print "Github release failed: Could not find Github auth token in %s: %s" % (token_path, exc)
        return False

    url = "https://api.github.com/repos/datawire/quark/releases?access_token=%(token)s" % locals()
    try:
        urllib2.urlopen(url, json.dumps(post_data))
        return True
    except Exception as exc:
        print "Github release failed: %s" % exc

    return False

def push(args):
    runtime_only = args["--runtime-only"]
    print "You are about to push the following packages live:"
    print
    if runtime_only:
        versions = [v for v in VERSIONS if v[0] != "quark"]
    else:
        versions = VERSIONS
    width = max(map(lambda x: len(x[0]), versions))
    for name, version in versions:
        print "    %*s: %s" % (width, name, version)
    print
    if challenge():
        print "Pushing"
        push_java()
        push_js()
        push_py()
        if not runtime_only:
            push_quark()
    else:
        print "Canceled"

def docs(args):
    version = metadata["__version__"]
    short = ".".join(version.split(".")[:2])
    docver = metadata["__doc_version__"]
    print "You are about to push the documentation live:"
    print
    print "    version: %s" % version
    print "        doc: %s" % docver
    print
    if challenge():
        print "Pushing docs"
        dest = tempfile.mkdtemp()
        run("git", "clone", call("git", "config", "--get", "remote.origin.url", dry=False).strip(),
            dest)
        run("git", "checkout", "gh-pages", cwd=dest)
        run("touch", ".nojekyll", cwd=dest)
        run("git", "rm", "-r", "--ignore-unmatch", short, cwd=dest)
        run("sphinx-build", "-q", "docs", os.path.join(dest, short), cwd=base())
        run("git", "add", ".", cwd=dest)
        run("git", "commit", "-m", "Documentation update %s-%s." % (version, docver), cwd=dest)
        run("git", "push", cwd=dest)
        print "Documentation is pushed."
    else:
        print "Canceled"

def show_metadata(args):
    names = metadata["__all__"] + ["__doc_version__"]
    width = max(map(lambda n: len(n.strip("_")), names))
    for name in names:
        print "%*s: %s" % (width, name.strip("_"), metadata[name])

## main

def main(args):
    global __dry__
    __dry__ = args["--dry"]
    check("pip", "mvn", "twine", "docker", "npm")
    pipcheck("wheel", "sphinx", "sphinx-better-theme")
    if args["version"]:
        version(args)
    elif args["dev"]:
        update_packages(dev=True)
    elif args["prod"]:
        update_packages(dev=False)
    elif args["push"]:
        push(args)
    elif args["docs"]:
        docs(args)
    elif args["metadata"]:
        show_metadata(args)
    else:
        assert False

def call_main(args):
    try:
        return main(args)
    except ReleaseError, e:
        return e

if __name__ == "__main__":
    exit(call_main(docopt(__doc__)))
