#!/usr/bin/env python

"""
Quark release tool. Because quark involves a variety of different
support packages for backend languages, the release process involves
dealing with a lot of different packaging tools and environments. This
utility captures all this in a single place.

Usage:
  release [--dry] cleanup
  release [--dry] prepare-release --prod [<version>] [--doc=<version>]
  release [--dry] push-release
  release [--dry] version [--dev | --prod] [<version>] [--doc=<version>]
  release [--dry | --cicd] push-pkgs
  release [--dry | --cicd] push-docs

  Options:
    --dry                  Dry run.
    --cicd                 Do not ask for challenge.

    --dev                  Change to development packages.
    --prod                 Change to production packages.

    --doc <version>        Documentation version.
"""

import json, os, random, re, subprocess, tempfile, urllib2
from docopt import docopt
from collections import OrderedDict
from semantic_version import Version as SemVer
try:  # py3
    from shlex import quote
except ImportError:  # py2
    from pipes import quote


__dir__ = None
__dry__ = False
__cicd__ = False

def base(name=None):
    global __dir__
    if __dir__ is None:
        __dir__ = call("git", "rev-parse", "--show-toplevel", dry=False).strip()
    if name:
        return os.path.join(__dir__, name)
    else:
        return __dir__


def _do(method, *command, **kwargs):
    dry = kwargs.pop("dry", __dry__)
    cmd =  " ".join(map(quote,command))
    if dry:
        print "$  #", cmd, kwargs
        return
    print "$   ", cmd, kwargs
    return method(command, **kwargs)

def call(*command, **kwargs):
    """Execute the supplied command and return the output."""
    return _do(subprocess.check_output, *command, **kwargs)

def run(*command, **kwargs):
    """Execute the supplied command."""
    _do(subprocess.check_call, *command, **kwargs)

metadata = {}
with open(base("quarkc/_metadata.py")) as fp:
    exec(fp.read(), metadata)
with open(base("docs/conf.py")) as fp:
    for line in fp:
        if line.startswith("__doc_version__"):
            exec(line, metadata)

## utilities

class ReleaseError(Exception):
    """An anticipated error."""

def check(*commands):
    """Check whether the supplied commands are available."""
    cmd = ["which"] + list(commands)
    try:
        subprocess.check_output(cmd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError, e:
        raise ReleaseError("Please install and configure missing prereqs: %s\n\n%s" %
                           (", ".join(commands), e.output))


def pipcheck(*packages):
    missing = []
    for pkg in packages:
        try:
            subprocess.check_output(["pip", "show", pkg], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError, e:
            missing.append(pkg)
    if missing:
        raise ReleaseError("Please install missing python packages: %s" % ", ".join(missing))

def update_json(name, **kwargs):
    """Update a json file with supplied overrides."""
    with open(name, "r") as fd:
        original = fd.read()
        obj = json.loads(original, object_pairs_hook=OrderedDict)
        obj.update(kwargs)
    updated = json.dumps(obj, indent=4, separators=(',', ': ')) + "\n"
    if updated != original:
        print "Updating json %s: %s" % (name, kwargs)
        if __dry__: return
        with open(name, "w") as fd:
            fd.write(updated)

def substitute(line, vars):
    """
    Substitute a line of python code declaring a variable of the form
    __<name>__ = <value>.  The name must be at the beginning of the
    line in order to match.
    """
    for key in vars:
        varname = "__%s__" % key
        if line.startswith(varname):
            return "%s = %s\n" % (varname, repr(vars[key]))
    else:
        return line

def update_python(name, **kwargs):
    """Update a python file with supplied overrides."""
    lines = []
    orig_lines = []
    with open(name, "r") as fd:
        for line in fd:
            orig_lines.append(line)
            lines.append(substitute(line, kwargs))
    updated = "".join(lines)
    original = "".join(orig_lines)
    if updated != original:
        print "Updating python %s: %s" % (name, kwargs)
        if __dry__: return True
        with open(name, "w") as fd:
            fd.write(updated)
        return True
    else:
        return False

def push_wheel(path):
    dest = tempfile.mkdtemp()
    run("python", "setup.py", "-q", "clean", "bdist_wheel", "-d", dest, cwd=base(path), dry=False)
    for name in os.listdir(dest):
        run("twine", "upload", "--skip-existing", os.path.join(dest, name), cwd=base())

## version update logic

def quark_version(version, doc_version, dev):
    if dev:
        title = "datawire-quarkdev"
    else:
        title = "datawire-quark"

    subs = {"title": title,
            "version": version,
            "doc_version": doc_version}

    updated = []
    for fname in ("quarkc/_metadata.py", "docs/conf.py"):
        if update_python(base(fname), **subs):
            updated.append(fname)

    return title, updated

def is_dev():
    return metadata["__title__"].endswith("dev")

## push logic

def push_quark():
    push_wheel(base())

## subcommands

def show_metadata():
    names = metadata["__all__"] + ["__doc_version__"]
    width = max(map(lambda n: len(n.strip("_")), names))
    for name in names:
        print "%*s: %s" % (width, name.strip("_"), metadata[name])

def version(args):
    if not (args["--dev"] or args["--prod"] or args["--doc"] or args["<version>"]):
        return show_metadata()

    if args["--dev"]:
        dev = True
    elif args["--prod"]:
        dev = False
    else:
        dev = is_dev()

    ver = args["<version>"]

    if ver:
        doc_default = "1"
    else:
        ver = metadata["__version__"]
        doc_default = metadata["__doc_version__"]

    docver = args["--doc"] or doc_default

    title, updated = quark_version(ver, docver, dev)
    dry = __dry__ or dev
    for fname in updated:
        run("git", "add", fname, cwd=base(), dry=dry)
    run("git", "commit", "-m", "Changed version to %s, %s (doc %s). [skip-ci]" % (title, ver, docver),
        cwd=base(), dry=dry)

def randstr():
    result = ""
    for i in range(4):
        result += chr(ord('a') + random.randint(0, 25))
    return result

def challenge():
    if __cicd__:
        print "No confirmation required, --cicd was provided"
        return True
    chal = randstr()
    text = raw_input('Please type "%s" to confirm: ' % chal)
    return text == chal

release_document_template = """
README file: https://github.com/datawire/quark/blob/%(tag)s/README.md

Full documentation: http://datawire.github.io/quark/%(short)s/index.html

We would appreciate your feedback! Please file issues here on Github.

For more information get in touch by email at hello@datawire.io or by Twitter at @datawireio.
"""

def make_github_release(tag, commitish=""):
    # Assumes that the tag already exists or the commit-ish is provided.
    major, minor, _ = tag.split(".", 2)
    short = major + "." + minor
    name = "Quark %s" % tag
    body = release_document_template.strip() % locals()
    post_data = dict(tag_name=tag, target_commitish=commitish, draft=False, prerelease=False, name=name, body=body)

    # Visit https://github.com/settings/tokens
    # Select "Generate new token"
    # Only required scope is "public_repo"
    # Paste resulting token (40 chars as of Jan 2016) into:
    token_path = "~/.github_public_repo_token"
    try:
        token = open(os.path.expanduser(token_path)).read().strip()
    except IOError as exc:
        print "Github release failed: Could not find Github auth token in %s: %s" % (token_path, exc)
        return False

    url = "https://api.github.com/repos/datawire/quark/releases?access_token=%(token)s" % locals()
    try:
        urllib2.urlopen(url, json.dumps(post_data))
        return True
    except Exception as exc:
        print "Github release failed: %s" % exc

    return False

def push_pkgs(args):
    print "You are about to push the following package live:"
    print
    print "    %s: %s" % (metadata["__title__"], metadata["__version__"])
    print
    if challenge():
        print "Pushing"
        push_quark()
    else:
        print "Canceled"

def push_docs(args):
    version = metadata["__version__"]
    short = ".".join(version.split(".")[:2])
    docver = metadata["__doc_version__"]
    if is_dev():
        docdest = os.path.join("dev", short)
    else:
        docdest = short
    print "You are about to push the documentation live:"
    print
    print "    version: %s" % version
    print "        doc: %s" % docver
    print "       dest: %s" % docdest
    print
    if challenge():
        print "Pushing docs"
        dest = tempfile.mkdtemp()
        run("git", "clone", "-b", "gh-pages", "--depth", "5",
            call("git", "config", "--get", "remote.origin.url", dry=False).strip(),
            dest)
        run("touch", ".nojekyll", cwd=dest)
        run("git", "rm", "-r", "--ignore-unmatch", docdest, cwd=dest)
        run("sphinx-build", "-q", "docs", os.path.join(dest, docdest), cwd=base())
        run(base("docs/substitute.sh"), dest)
        run("git", "add", ".", cwd=dest)
        run("git", "commit", "-m", "Documentation update %s-%s." % (version, docver), cwd=dest)
        run("git", "push", "origin", "gh-pages", cwd=dest)
        print "Documentation is pushed."
    else:
        print "Canceled"


RELEASE_BRANCH="release-in-progress"

def in_release():
    return call("git", "branch", "--list", RELEASE_BRANCH+"*", dry=False).splitlines()

def is_dirty():
    return call("git", "status", "--porcelain", "--untracked=no", dry=False).splitlines()

def current_branch():
    return call("git", "symbolic-ref", "--short", "HEAD", dry=False).strip()

def tag_at(refspec):
    return call("git", "describe", "--exact-match", refspec, dry=False).strip()

def revparse(refspec):
    return call("git", "rev-parse", refspec, dry=False).strip()

def is_branch_at(branch, refspec):
    return revparse(branch) == revparse(refspec)

def ensure_clean():
    if is_dirty():
        run("git", "status", "--untracked=no", dry=False)
        raise ReleaseError("Aborted\n\nCannot release from a dirty worktree")

def ensure_releasing():
    releasing = in_release()
    if not releasing:
        print "Not in a release"
        return

def validate_release_tag(tag):
        assert tag.startswith("v"), "non-release tag %r found on release branch" % tag
        try:
            SemVer(tag[1:])
        except:
            assert False, "non-release tag %r found on release branch" % tag

def format_release_tag(ver):
    return "v%s" % ver

def prepare_release(args):
    ensure_clean()
    releasing = in_release()
    if releasing:
        raise ReleaseError("Release appears to be in progress, found %s\n\n%s" % (
            releasing,"Investigate and run ./release cleanup"))
    if not args["--prod"]:
        raise ReleaseError("only for production releases, missing --prod")
    run("git", "checkout",  "develop")
    run("git", "pull")
    next_ver = call("scripts/compute-next-version", dry=False).strip()
    actual_tag = call("git", "describe", dry=False).strip()
    expected_tag = "dev-%s" % next_ver
    if expected_tag != actual_tag:
        raise ReleaseError("Develop branch is not stable, got '%s' expected '%s'\n\n%s" % (
            actual_tag, expected_tag,
            "Aborting. Please wait for CI to catch up and retry later"));
    ver = args["<version>"]
    if not ver:
        print "No version override supplied, using automatic version %s" % next_ver
        ver = args["<version>"] = next_ver
    else:
        if SemVer(ver) < SemVer(next_ver):
            raise ReleaseError("Supplied version %s < %s. Aborting" % (
                ver, next_ver));
        else:
            print "Supplied version %s accepted" % ver
    run("git", "checkout",  "master")
    run("git", "pull")
    run("git", "checkout", "-b", RELEASE_BRANCH)
    run("git", "merge", "develop", "-m", "Merge branch develop into master")
    version(args)
    release_tag = format_release_tag(ver)
    run("git", "tag", "-s", "-m", "Release of %s" % (ver, ), release_tag)


def enumerate_refspecs(revision_range):
    """return tags, branches that point in the specified revision range"""
    tags = []
    branches = []
    for refs in call("git", "log", "--pretty=%D",
                      *revision_range, dry=False).splitlines():
        for sref in refs.split(","):
            ref = sref.split()
            assert 1 <= len(ref) <= 3, "unrecognized refspect format %r" % sref
            if len(ref) == 1:
                branch = ref[0]
                if branch != "HEAD":
                    branches.append(branch)
            elif len(ref) == 2:
                assert ref[0] == "tag:", "Unrecognized ref annotation %r" % sref
                tags.append(ref[1])
            elif len(ref) == 3:
                assert ref[0] == "HEAD" and ref[1] == "->", "Unrecognized ref annotation %r" % sref
                branches.append(ref[2])
    return tags, branches

def cleanup(args):
    ensure_clean()
    ensure_releasing()
    print
    print "Cleanup of in-progress release"
    print
    revision_range = [RELEASE_BRANCH, "--not", "origin/develop", "origin/master"]
    tags, branches = enumerate_refspecs(revision_range)
    for tag in tags:
        validate_release_tag(tag)
    if not branches and is_branch_at(RELEASE_BRANCH, "master"):
        print "Release branch is still at master"
        branches.append(RELEASE_BRANCH)
        assert not tags, "Confused script, expected no tags in this case but found %s" % tags
        print
        print "Branches to be removed:", branches
    else:
        print
        print "Branches to be removed:", branches
        print "Tags to be removed:", tags
        assert (RELEASE_BRANCH,) == tuple(branches), "Confused script, expected to find exactly %r amongst %r" % (RELEASE_BRANCH, branches)
        assert len(tags) <= 1, "Confused script, expected to find at most one tag to remove, but found %s" % len(tags)
        print
        print "This operation will drop the following commits:"
        print
        run("git", "log", "--decorate", "--oneline", *revision_range, dry=False)
    print
    if challenge():
        run("git", "checkout", "develop")
        run("git", "branch", "-D", *branches)
        if tags:
            run("git", "tag", "-d", *tags)
    else:
        print "Cancelled";

## main

def main(args):
    global __dry__, __cicd__
    __dry__ = args["--dry"]
    __cicd__ = args["--cicd"]
    check("pip", "twine", "git")
    pipcheck("wheel", "sphinx", "sphinx-better-theme")
    if args["version"]:
        version(args)
    elif args["push-pkgs"]:
        push_pkgs(args)
    elif args["push-docs"]:
        push_docs(args)
    elif args["prepare-release"]:
        prepare_release(args)
    elif args["cleanup"]:
        cleanup(args)
    elif args["push-release"]:
        push_release(args)
    else:
        assert False

def call_main(args):
    try:
        return main(args)
    except ReleaseError, e:
        return e

if __name__ == "__main__":
    exit(call_main(docopt(__doc__)))
