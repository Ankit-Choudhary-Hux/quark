# Generated from QuarkParser.g4 by ANTLR 4.6
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u">\u01ad\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30")
        buf.write(u"\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t")
        buf.write(u"\35\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\3\2\7\2F")
        buf.write(u"\n\2\f\2\16\2I\13\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\5\3R")
        buf.write(u"\n\3\3\4\3\4\3\4\3\4\7\4X\n\4\f\4\16\4[\13\4\3\4\3\4")
        buf.write(u"\3\5\5\5`\n\5\3\5\3\5\3\5\3\5\3\5\7\5g\n\5\f\5\16\5j")
        buf.write(u"\13\5\5\5l\n\5\3\5\3\5\3\5\3\5\5\5r\n\5\3\6\3\6\3\6\3")
        buf.write(u"\7\3\7\3\7\5\7z\n\7\3\7\7\7}\n\7\f\7\16\7\u0080\13\7")
        buf.write(u"\3\7\3\7\7\7\u0084\n\7\f\7\16\7\u0087\13\7\3\7\3\7\3")
        buf.write(u"\b\3\b\3\b\5\b\u008e\n\b\3\b\3\b\7\b\u0092\n\b\f\b\16")
        buf.write(u"\b\u0095\13\b\3\b\3\b\3\t\3\t\3\t\5\t\u009c\n\t\3\t\3")
        buf.write(u"\t\3\t\3\t\5\t\u00a2\n\t\5\t\u00a4\n\t\3\t\3\t\3\t\7")
        buf.write(u"\t\u00a9\n\t\f\t\16\t\u00ac\13\t\3\t\3\t\3\n\3\n\3\n")
        buf.write(u"\3\n\7\n\u00b4\n\n\f\n\16\n\u00b7\13\n\3\n\3\n\3\13\3")
        buf.write(u"\13\3\13\5\13\u00be\n\13\3\f\3\f\3\f\3\f\5\f\u00c4\n")
        buf.write(u"\f\3\f\3\f\3\r\3\r\3\r\3\r\7\r\u00cc\n\r\f\r\16\r\u00cf")
        buf.write(u"\13\r\3\r\3\r\7\r\u00d3\n\r\f\r\16\r\u00d6\13\r\3\r\3")
        buf.write(u"\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\7\16\u00e2")
        buf.write(u"\n\16\f\16\16\16\u00e5\13\16\3\16\5\16\u00e8\n\16\3\17")
        buf.write(u"\3\17\7\17\u00ec\n\17\f\17\16\17\u00ef\13\17\3\17\3\17")
        buf.write(u"\3\20\3\20\3\20\3\20\5\20\u00f7\n\20\3\21\3\21\3\21\3")
        buf.write(u"\21\3\21\3\21\5\21\u00ff\n\21\3\22\3\22\3\22\3\22\5\22")
        buf.write(u"\u0105\n\22\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3")
        buf.write(u"\24\3\24\3\24\3\24\3\24\3\24\5\24\u0115\n\24\3\25\3\25")
        buf.write(u"\3\26\3\26\3\27\3\27\3\30\3\30\5\30\u011f\n\30\3\31\3")
        buf.write(u"\31\3\31\5\31\u0124\n\31\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write(u"\3\32\5\32\u012d\n\32\3\33\3\33\3\33\3\33\3\33\3\33\3")
        buf.write(u"\34\3\34\3\34\3\34\3\34\3\34\6\34\u013b\n\34\r\34\16")
        buf.write(u"\34\u013c\3\34\3\34\3\35\3\35\3\35\3\35\6\35\u0145\n")
        buf.write(u"\35\r\35\16\35\u0146\3\36\3\36\3\36\3\36\3\36\3\36\3")
        buf.write(u"\36\3\36\3\36\3\36\3\36\7\36\u0154\n\36\f\36\16\36\u0157")
        buf.write(u"\13\36\5\36\u0159\n\36\3\36\3\36\3\36\3\36\3\36\3\36")
        buf.write(u"\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\5\36\u0169\n")
        buf.write(u"\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36")
        buf.write(u"\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3")
        buf.write(u"\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36")
        buf.write(u"\7\36\u018a\n\36\f\36\16\36\u018d\13\36\3\37\3\37\3\37")
        buf.write(u"\3\37\3 \3 \3 \7 \u0196\n \f \16 \u0199\13 \5 \u019b")
        buf.write(u"\n \3!\3!\3!\3!\3!\7!\u01a2\n!\f!\16!\u01a5\13!\3!\3")
        buf.write(u"!\5!\u01a9\n!\3\"\3\"\3\"\2\3:#\2\4\6\b\n\f\16\20\22")
        buf.write(u"\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@B\2\7\4\2")
        buf.write(u"&&*+\3\2\')\3\2%&\4\2\26\27#$\3\2!\"\u01cf\2G\3\2\2\2")
        buf.write(u"\4Q\3\2\2\2\6S\3\2\2\2\b_\3\2\2\2\ns\3\2\2\2\fv\3\2\2")
        buf.write(u"\2\16\u008a\3\2\2\2\20\u0098\3\2\2\2\22\u00af\3\2\2\2")
        buf.write(u"\24\u00ba\3\2\2\2\26\u00bf\3\2\2\2\30\u00c7\3\2\2\2\32")
        buf.write(u"\u00e7\3\2\2\2\34\u00e9\3\2\2\2\36\u00f6\3\2\2\2 \u00fe")
        buf.write(u"\3\2\2\2\"\u0100\3\2\2\2$\u0106\3\2\2\2&\u0114\3\2\2")
        buf.write(u"\2(\u0116\3\2\2\2*\u0118\3\2\2\2,\u011a\3\2\2\2.\u011c")
        buf.write(u"\3\2\2\2\60\u0123\3\2\2\2\62\u0125\3\2\2\2\64\u012e\3")
        buf.write(u"\2\2\2\66\u0134\3\2\2\28\u0140\3\2\2\2:\u0168\3\2\2\2")
        buf.write(u"<\u018e\3\2\2\2>\u019a\3\2\2\2@\u019c\3\2\2\2B\u01aa")
        buf.write(u"\3\2\2\2DF\5\4\3\2ED\3\2\2\2FI\3\2\2\2GE\3\2\2\2GH\3")
        buf.write(u"\2\2\2HJ\3\2\2\2IG\3\2\2\2JK\7\2\2\3K\3\3\2\2\2LR\5\6")
        buf.write(u"\4\2MR\5\b\5\2NR\5\f\7\2OR\5\16\b\2PR\5\20\t\2QL\3\2")
        buf.write(u"\2\2QM\3\2\2\2QN\3\2\2\2QO\3\2\2\2QP\3\2\2\2R\5\3\2\2")
        buf.write(u"\2ST\7\6\2\2TU\5B\"\2UY\7\24\2\2VX\5\4\3\2WV\3\2\2\2")
        buf.write(u"X[\3\2\2\2YW\3\2\2\2YZ\3\2\2\2Z\\\3\2\2\2[Y\3\2\2\2\\")
        buf.write(u"]\7\25\2\2]\7\3\2\2\2^`\5@!\2_^\3\2\2\2_`\3\2\2\2`a\3")
        buf.write(u"\2\2\2ab\5B\"\2bk\7\31\2\2ch\5\n\6\2de\7\30\2\2eg\5\n")
        buf.write(u"\6\2fd\3\2\2\2gj\3\2\2\2hf\3\2\2\2hi\3\2\2\2il\3\2\2")
        buf.write(u"\2jh\3\2\2\2kc\3\2\2\2kl\3\2\2\2lm\3\2\2\2mq\7\32\2\2")
        buf.write(u"nr\5\30\r\2or\5\34\17\2pr\7\35\2\2qn\3\2\2\2qo\3\2\2")
        buf.write(u"\2qp\3\2\2\2r\t\3\2\2\2st\5@!\2tu\5B\"\2u\13\3\2\2\2")
        buf.write(u"vw\7\7\2\2wy\5B\"\2xz\5\22\n\2yx\3\2\2\2yz\3\2\2\2z~")
        buf.write(u"\3\2\2\2{}\5\30\r\2|{\3\2\2\2}\u0080\3\2\2\2~|\3\2\2")
        buf.write(u"\2~\177\3\2\2\2\177\u0081\3\2\2\2\u0080~\3\2\2\2\u0081")
        buf.write(u"\u0085\7\24\2\2\u0082\u0084\5\b\5\2\u0083\u0082\3\2\2")
        buf.write(u"\2\u0084\u0087\3\2\2\2\u0085\u0083\3\2\2\2\u0085\u0086")
        buf.write(u"\3\2\2\2\u0086\u0088\3\2\2\2\u0087\u0085\3\2\2\2\u0088")
        buf.write(u"\u0089\7\25\2\2\u0089\r\3\2\2\2\u008a\u008b\7\b\2\2\u008b")
        buf.write(u"\u008d\5B\"\2\u008c\u008e\5\22\n\2\u008d\u008c\3\2\2")
        buf.write(u"\2\u008d\u008e\3\2\2\2\u008e\u008f\3\2\2\2\u008f\u0093")
        buf.write(u"\7\24\2\2\u0090\u0092\5\b\5\2\u0091\u0090\3\2\2\2\u0092")
        buf.write(u"\u0095\3\2\2\2\u0093\u0091\3\2\2\2\u0093\u0094\3\2\2")
        buf.write(u"\2\u0094\u0096\3\2\2\2\u0095\u0093\3\2\2\2\u0096\u0097")
        buf.write(u"\7\25\2\2\u0097\17\3\2\2\2\u0098\u0099\7\t\2\2\u0099")
        buf.write(u"\u009b\5B\"\2\u009a\u009c\5\22\n\2\u009b\u009a\3\2\2")
        buf.write(u"\2\u009b\u009c\3\2\2\2\u009c\u00a3\3\2\2\2\u009d\u009e")
        buf.write(u"\7\n\2\2\u009e\u00a1\5@!\2\u009f\u00a0\7\30\2\2\u00a0")
        buf.write(u"\u00a2\5@!\2\u00a1\u009f\3\2\2\2\u00a1\u00a2\3\2\2\2")
        buf.write(u"\u00a2\u00a4\3\2\2\2\u00a3\u009d\3\2\2\2\u00a3\u00a4")
        buf.write(u"\3\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00aa\7\24\2\2\u00a6")
        buf.write(u"\u00a9\5\26\f\2\u00a7\u00a9\5\b\5\2\u00a8\u00a6\3\2\2")
        buf.write(u"\2\u00a8\u00a7\3\2\2\2\u00a9\u00ac\3\2\2\2\u00aa\u00a8")
        buf.write(u"\3\2\2\2\u00aa\u00ab\3\2\2\2\u00ab\u00ad\3\2\2\2\u00ac")
        buf.write(u"\u00aa\3\2\2\2\u00ad\u00ae\7\25\2\2\u00ae\21\3\2\2\2")
        buf.write(u"\u00af\u00b0\7\26\2\2\u00b0\u00b5\5\24\13\2\u00b1\u00b2")
        buf.write(u"\7\30\2\2\u00b2\u00b4\5\24\13\2\u00b3\u00b1\3\2\2\2\u00b4")
        buf.write(u"\u00b7\3\2\2\2\u00b5\u00b3\3\2\2\2\u00b5\u00b6\3\2\2")
        buf.write(u"\2\u00b6\u00b8\3\2\2\2\u00b7\u00b5\3\2\2\2\u00b8\u00b9")
        buf.write(u"\7\27\2\2\u00b9\23\3\2\2\2\u00ba\u00bd\5B\"\2\u00bb\u00bc")
        buf.write(u"\7\n\2\2\u00bc\u00be\5@!\2\u00bd\u00bb\3\2\2\2\u00bd")
        buf.write(u"\u00be\3\2\2\2\u00be\25\3\2\2\2\u00bf\u00c0\5@!\2\u00c0")
        buf.write(u"\u00c3\5B\"\2\u00c1\u00c2\7 \2\2\u00c2\u00c4\5:\36\2")
        buf.write(u"\u00c3\u00c1\3\2\2\2\u00c3\u00c4\3\2\2\2\u00c4\u00c5")
        buf.write(u"\3\2\2\2\u00c5\u00c6\7\35\2\2\u00c6\27\3\2\2\2\u00c7")
        buf.write(u"\u00c8\7\60\2\2\u00c8\u00cd\7\65\2\2\u00c9\u00ca\7\64")
        buf.write(u"\2\2\u00ca\u00cc\7\66\2\2\u00cb\u00c9\3\2\2\2\u00cc\u00cf")
        buf.write(u"\3\2\2\2\u00cd\u00cb\3\2\2\2\u00cd\u00ce\3\2\2\2\u00ce")
        buf.write(u"\u00d0\3\2\2\2\u00cf\u00cd\3\2\2\2\u00d0\u00d4\7\67\2")
        buf.write(u"\2\u00d1\u00d3\5\32\16\2\u00d2\u00d1\3\2\2\2\u00d3\u00d6")
        buf.write(u"\3\2\2\2\u00d4\u00d2\3\2\2\2\u00d4\u00d5\3\2\2\2\u00d5")
        buf.write(u"\u00d7\3\2\2\2\u00d6\u00d4\3\2\2\2\u00d7\u00d8\7=\2\2")
        buf.write(u"\u00d8\31\3\2\2\2\u00d9\u00e8\79\2\2\u00da\u00e8\7:\2")
        buf.write(u"\2\u00db\u00dc\7;\2\2\u00dc\u00dd\5:\36\2\u00dd\u00de")
        buf.write(u"\7\32\2\2\u00de\u00e8\3\2\2\2\u00df\u00e3\7<\2\2\u00e0")
        buf.write(u"\u00e2\5\32\16\2\u00e1\u00e0\3\2\2\2\u00e2\u00e5\3\2")
        buf.write(u"\2\2\u00e3\u00e1\3\2\2\2\u00e3\u00e4\3\2\2\2\u00e4\u00e6")
        buf.write(u"\3\2\2\2\u00e5\u00e3\3\2\2\2\u00e6\u00e8\7=\2\2\u00e7")
        buf.write(u"\u00d9\3\2\2\2\u00e7\u00da\3\2\2\2\u00e7\u00db\3\2\2")
        buf.write(u"\2\u00e7\u00df\3\2\2\2\u00e8\33\3\2\2\2\u00e9\u00ed\7")
        buf.write(u"\24\2\2\u00ea\u00ec\5\36\20\2\u00eb\u00ea\3\2\2\2\u00ec")
        buf.write(u"\u00ef\3\2\2\2\u00ed\u00eb\3\2\2\2\u00ed\u00ee\3\2\2")
        buf.write(u"\2\u00ee\u00f0\3\2\2\2\u00ef\u00ed\3\2\2\2\u00f0\u00f1")
        buf.write(u"\7\25\2\2\u00f1\35\3\2\2\2\u00f2\u00f3\5 \21\2\u00f3")
        buf.write(u"\u00f4\7\35\2\2\u00f4\u00f7\3\2\2\2\u00f5\u00f7\5\60")
        buf.write(u"\31\2\u00f6\u00f2\3\2\2\2\u00f6\u00f5\3\2\2\2\u00f7\37")
        buf.write(u"\3\2\2\2\u00f8\u00ff\5\"\22\2\u00f9\u00ff\5(\25\2\u00fa")
        buf.write(u"\u00ff\5$\23\2\u00fb\u00ff\5.\30\2\u00fc\u00ff\5*\26")
        buf.write(u"\2\u00fd\u00ff\5,\27\2\u00fe\u00f8\3\2\2\2\u00fe\u00f9")
        buf.write(u"\3\2\2\2\u00fe\u00fa\3\2\2\2\u00fe\u00fb\3\2\2\2\u00fe")
        buf.write(u"\u00fc\3\2\2\2\u00fe\u00fd\3\2\2\2\u00ff!\3\2\2\2\u0100")
        buf.write(u"\u0101\5@!\2\u0101\u0104\5B\"\2\u0102\u0103\7 \2\2\u0103")
        buf.write(u"\u0105\5:\36\2\u0104\u0102\3\2\2\2\u0104\u0105\3\2\2")
        buf.write(u"\2\u0105#\3\2\2\2\u0106\u0107\5&\24\2\u0107\u0108\7 ")
        buf.write(u"\2\2\u0108\u0109\5:\36\2\u0109%\3\2\2\2\u010a\u0115\5")
        buf.write(u"B\"\2\u010b\u010c\5:\36\2\u010c\u010d\7\33\2\2\u010d")
        buf.write(u"\u010e\5:\36\2\u010e\u010f\7\34\2\2\u010f\u0115\3\2\2")
        buf.write(u"\2\u0110\u0111\5:\36\2\u0111\u0112\7\37\2\2\u0112\u0113")
        buf.write(u"\5B\"\2\u0113\u0115\3\2\2\2\u0114\u010a\3\2\2\2\u0114")
        buf.write(u"\u010b\3\2\2\2\u0114\u0110\3\2\2\2\u0115\'\3\2\2\2\u0116")
        buf.write(u"\u0117\5:\36\2\u0117)\3\2\2\2\u0118\u0119\7\22\2\2\u0119")
        buf.write(u"+\3\2\2\2\u011a\u011b\7\23\2\2\u011b-\3\2\2\2\u011c\u011e")
        buf.write(u"\7\16\2\2\u011d\u011f\5:\36\2\u011e\u011d\3\2\2\2\u011e")
        buf.write(u"\u011f\3\2\2\2\u011f/\3\2\2\2\u0120\u0124\5\62\32\2\u0121")
        buf.write(u"\u0124\5\64\33\2\u0122\u0124\5\66\34\2\u0123\u0120\3")
        buf.write(u"\2\2\2\u0123\u0121\3\2\2\2\u0123\u0122\3\2\2\2\u0124")
        buf.write(u"\61\3\2\2\2\u0125\u0126\7\f\2\2\u0126\u0127\7\31\2\2")
        buf.write(u"\u0127\u0128\5:\36\2\u0128\u0129\7\32\2\2\u0129\u012c")
        buf.write(u"\5\34\17\2\u012a\u012b\7\r\2\2\u012b\u012d\5\34\17\2")
        buf.write(u"\u012c\u012a\3\2\2\2\u012c\u012d\3\2\2\2\u012d\63\3\2")
        buf.write(u"\2\2\u012e\u012f\7\17\2\2\u012f\u0130\7\31\2\2\u0130")
        buf.write(u"\u0131\5:\36\2\u0131\u0132\7\32\2\2\u0132\u0133\5\34")
        buf.write(u"\17\2\u0133\65\3\2\2\2\u0134\u0135\7\20\2\2\u0135\u0136")
        buf.write(u"\7\31\2\2\u0136\u0137\5:\36\2\u0137\u0138\7\32\2\2\u0138")
        buf.write(u"\u013a\7\24\2\2\u0139\u013b\58\35\2\u013a\u0139\3\2\2")
        buf.write(u"\2\u013b\u013c\3\2\2\2\u013c\u013a\3\2\2\2\u013c\u013d")
        buf.write(u"\3\2\2\2\u013d\u013e\3\2\2\2\u013e\u013f\7\25\2\2\u013f")
        buf.write(u"\67\3\2\2\2\u0140\u0141\7\21\2\2\u0141\u0142\5> \2\u0142")
        buf.write(u"\u0144\7\36\2\2\u0143\u0145\5\36\20\2\u0144\u0143\3\2")
        buf.write(u"\2\2\u0145\u0146\3\2\2\2\u0146\u0144\3\2\2\2\u0146\u0147")
        buf.write(u"\3\2\2\2\u01479\3\2\2\2\u0148\u0149\b\36\1\2\u0149\u0169")
        buf.write(u"\7/\2\2\u014a\u0169\7.\2\2\u014b\u014c\7\33\2\2\u014c")
        buf.write(u"\u014d\5> \2\u014d\u014e\7\34\2\2\u014e\u0169\3\2\2\2")
        buf.write(u"\u014f\u0158\7\24\2\2\u0150\u0155\5<\37\2\u0151\u0152")
        buf.write(u"\7\30\2\2\u0152\u0154\5<\37\2\u0153\u0151\3\2\2\2\u0154")
        buf.write(u"\u0157\3\2\2\2\u0155\u0153\3\2\2\2\u0155\u0156\3\2\2")
        buf.write(u"\2\u0156\u0159\3\2\2\2\u0157\u0155\3\2\2\2\u0158\u0150")
        buf.write(u"\3\2\2\2\u0158\u0159\3\2\2\2\u0159\u015a\3\2\2\2\u015a")
        buf.write(u"\u0169\7\25\2\2\u015b\u0169\5B\"\2\u015c\u015d\7\31\2")
        buf.write(u"\2\u015d\u015e\5:\36\2\u015e\u015f\7\32\2\2\u015f\u0169")
        buf.write(u"\3\2\2\2\u0160\u0161\t\2\2\2\u0161\u0169\5:\36\n\u0162")
        buf.write(u"\u0163\7\13\2\2\u0163\u0164\5@!\2\u0164\u0165\7\31\2")
        buf.write(u"\2\u0165\u0166\5> \2\u0166\u0167\7\32\2\2\u0167\u0169")
        buf.write(u"\3\2\2\2\u0168\u0148\3\2\2\2\u0168\u014a\3\2\2\2\u0168")
        buf.write(u"\u014b\3\2\2\2\u0168\u014f\3\2\2\2\u0168\u015b\3\2\2")
        buf.write(u"\2\u0168\u015c\3\2\2\2\u0168\u0160\3\2\2\2\u0168\u0162")
        buf.write(u"\3\2\2\2\u0169\u018b\3\2\2\2\u016a\u016b\f\b\2\2\u016b")
        buf.write(u"\u016c\t\3\2\2\u016c\u018a\5:\36\t\u016d\u016e\f\7\2")
        buf.write(u"\2\u016e\u016f\t\4\2\2\u016f\u018a\5:\36\7\u0170\u0171")
        buf.write(u"\f\6\2\2\u0171\u0172\t\5\2\2\u0172\u018a\5:\36\7\u0173")
        buf.write(u"\u0174\f\5\2\2\u0174\u0175\t\6\2\2\u0175\u018a\5:\36")
        buf.write(u"\6\u0176\u0177\f\4\2\2\u0177\u0178\7,\2\2\u0178\u018a")
        buf.write(u"\5:\36\5\u0179\u017a\f\3\2\2\u017a\u017b\7-\2\2\u017b")
        buf.write(u"\u018a\5:\36\4\u017c\u017d\f\r\2\2\u017d\u017e\7\37\2")
        buf.write(u"\2\u017e\u018a\5B\"\2\u017f\u0180\f\f\2\2\u0180\u0181")
        buf.write(u"\7\31\2\2\u0181\u0182\5> \2\u0182\u0183\7\32\2\2\u0183")
        buf.write(u"\u018a\3\2\2\2\u0184\u0185\f\13\2\2\u0185\u0186\7\33")
        buf.write(u"\2\2\u0186\u0187\5:\36\2\u0187\u0188\7\34\2\2\u0188\u018a")
        buf.write(u"\3\2\2\2\u0189\u016a\3\2\2\2\u0189\u016d\3\2\2\2\u0189")
        buf.write(u"\u0170\3\2\2\2\u0189\u0173\3\2\2\2\u0189\u0176\3\2\2")
        buf.write(u"\2\u0189\u0179\3\2\2\2\u0189\u017c\3\2\2\2\u0189\u017f")
        buf.write(u"\3\2\2\2\u0189\u0184\3\2\2\2\u018a\u018d\3\2\2\2\u018b")
        buf.write(u"\u0189\3\2\2\2\u018b\u018c\3\2\2\2\u018c;\3\2\2\2\u018d")
        buf.write(u"\u018b\3\2\2\2\u018e\u018f\5:\36\2\u018f\u0190\7\36\2")
        buf.write(u"\2\u0190\u0191\5:\36\2\u0191=\3\2\2\2\u0192\u0197\5:")
        buf.write(u"\36\2\u0193\u0194\7\30\2\2\u0194\u0196\5:\36\2\u0195")
        buf.write(u"\u0193\3\2\2\2\u0196\u0199\3\2\2\2\u0197\u0195\3\2\2")
        buf.write(u"\2\u0197\u0198\3\2\2\2\u0198\u019b\3\2\2\2\u0199\u0197")
        buf.write(u"\3\2\2\2\u019a\u0192\3\2\2\2\u019a\u019b\3\2\2\2\u019b")
        buf.write(u"?\3\2\2\2\u019c\u01a8\5B\"\2\u019d\u019e\7\26\2\2\u019e")
        buf.write(u"\u01a3\5@!\2\u019f\u01a0\7\30\2\2\u01a0\u01a2\5@!\2\u01a1")
        buf.write(u"\u019f\3\2\2\2\u01a2\u01a5\3\2\2\2\u01a3\u01a1\3\2\2")
        buf.write(u"\2\u01a3\u01a4\3\2\2\2\u01a4\u01a6\3\2\2\2\u01a5\u01a3")
        buf.write(u"\3\2\2\2\u01a6\u01a7\7\27\2\2\u01a7\u01a9\3\2\2\2\u01a8")
        buf.write(u"\u019d\3\2\2\2\u01a8\u01a9\3\2\2\2\u01a9A\3\2\2\2\u01aa")
        buf.write(u"\u01ab\7\61\2\2\u01abC\3\2\2\2-GQY_hkqy~\u0085\u008d")
        buf.write(u"\u0093\u009b\u00a1\u00a3\u00a8\u00aa\u00b5\u00bd\u00c3")
        buf.write(u"\u00cd\u00d4\u00e3\u00e7\u00ed\u00f6\u00fe\u0104\u0114")
        buf.write(u"\u011e\u0123\u012c\u013c\u0146\u0155\u0158\u0168\u0189")
        buf.write(u"\u018b\u0197\u019a\u01a3\u01a8")
        return buf.getvalue()


class QuarkParser ( Parser ):

    grammarFileName = "QuarkParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"'namespace'", u"'primitive'", u"'interface'", u"'class'", 
                     u"'extends'", u"'new'", u"'if'", u"'else'", u"'return'", 
                     u"'while'", u"'switch'", u"'case'", u"'break'", u"'continue'", 
                     u"<INVALID>", u"<INVALID>", u"'<'", u"'>'", u"','", 
                     u"'('", u"')'", u"'['", u"']'", u"';'", u"':'", u"'.'", 
                     u"'='", u"'=='", u"'!='", u"'<='", u"'>='", u"'+'", 
                     u"'-'", u"'*'", u"'/'", u"'%'", u"'!'", u"'?'", u"'&&'", 
                     u"'||'", u"<INVALID>", u"<INVALID>", u"'for'", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"'import'", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"'$('" ]

    symbolicNames = [ u"<INVALID>", u"WS", u"COMMENT", u"MULTILINE_COMMENT", 
                      u"NAMESPACE", u"PRIMITIVE", u"INTERFACE", u"CLASS", 
                      u"EXTENDS", u"NEW", u"IF", u"ELSE", u"RETURN", u"WHILE", 
                      u"SWITCH", u"CASE", u"BREAK", u"CONTINUE", u"LBRACE", 
                      u"RBRACE", u"LT", u"GT", u"COMMA", u"LPAREN", u"RPAREN", 
                      u"LBRACK", u"RBRACK", u"SEMI", u"COLON", u"DOT", u"EQ", 
                      u"EQL", u"NEQ", u"LE", u"GE", u"PLUS", u"MINUS", u"MUL", 
                      u"DIV", u"MOD", u"BANG", u"QMARK", u"AND", u"OR", 
                      u"STRING", u"NUMBER", u"FOR_LANG", u"ID", u"ERROR", 
                      u"NATIVE_WS", u"IMPORT", u"LANG", u"ISTRING", u"NATIVE_START", 
                      u"NATIVE_HEADER_ERROR", u"NATIVE_CODE", u"QVAR", u"QEXPR", 
                      u"NATIVE_LBRACE", u"NATIVE_RBRACE", u"NATIVE_ERROR" ]

    RULE_qfile = 0
    RULE_definition = 1
    RULE_namespace = 2
    RULE_function = 3
    RULE_parameter = 4
    RULE_primitive = 5
    RULE_qinterface = 6
    RULE_qclass = 7
    RULE_tparams = 8
    RULE_tparam = 9
    RULE_field = 10
    RULE_native_body = 11
    RULE_native_fragment = 12
    RULE_body = 13
    RULE_statement = 14
    RULE_simple = 15
    RULE_local = 16
    RULE_assign = 17
    RULE_lhs = 18
    RULE_evaluate = 19
    RULE_qbreak = 20
    RULE_qcontinue = 21
    RULE_qreturn = 22
    RULE_compound = 23
    RULE_qif = 24
    RULE_qwhile = 25
    RULE_qswitch = 26
    RULE_qcase = 27
    RULE_expr = 28
    RULE_entry = 29
    RULE_exprs = 30
    RULE_qtype = 31
    RULE_name = 32

    ruleNames =  [ u"qfile", u"definition", u"namespace", u"function", u"parameter", 
                   u"primitive", u"qinterface", u"qclass", u"tparams", u"tparam", 
                   u"field", u"native_body", u"native_fragment", u"body", 
                   u"statement", u"simple", u"local", u"assign", u"lhs", 
                   u"evaluate", u"qbreak", u"qcontinue", u"qreturn", u"compound", 
                   u"qif", u"qwhile", u"qswitch", u"qcase", u"expr", u"entry", 
                   u"exprs", u"qtype", u"name" ]

    EOF = Token.EOF
    WS=1
    COMMENT=2
    MULTILINE_COMMENT=3
    NAMESPACE=4
    PRIMITIVE=5
    INTERFACE=6
    CLASS=7
    EXTENDS=8
    NEW=9
    IF=10
    ELSE=11
    RETURN=12
    WHILE=13
    SWITCH=14
    CASE=15
    BREAK=16
    CONTINUE=17
    LBRACE=18
    RBRACE=19
    LT=20
    GT=21
    COMMA=22
    LPAREN=23
    RPAREN=24
    LBRACK=25
    RBRACK=26
    SEMI=27
    COLON=28
    DOT=29
    EQ=30
    EQL=31
    NEQ=32
    LE=33
    GE=34
    PLUS=35
    MINUS=36
    MUL=37
    DIV=38
    MOD=39
    BANG=40
    QMARK=41
    AND=42
    OR=43
    STRING=44
    NUMBER=45
    FOR_LANG=46
    ID=47
    ERROR=48
    NATIVE_WS=49
    IMPORT=50
    LANG=51
    ISTRING=52
    NATIVE_START=53
    NATIVE_HEADER_ERROR=54
    NATIVE_CODE=55
    QVAR=56
    QEXPR=57
    NATIVE_LBRACE=58
    NATIVE_RBRACE=59
    NATIVE_ERROR=60

    def __init__(self, input):
        super(QuarkParser, self).__init__(input)
        self.checkVersion("4.6")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class QfileContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QfileContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._definition = None # DefinitionContext
            self.definitions = list() # of DefinitionContexts

        def EOF(self):
            return self.getToken(QuarkParser.EOF, 0)

        def definition(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.DefinitionContext)
            else:
                return self.getTypedRuleContext(QuarkParser.DefinitionContext,i)


        def getRuleIndex(self):
            return QuarkParser.RULE_qfile

        def enterRule(self, listener):
            if hasattr(listener, "enterQfile"):
                listener.enterQfile(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQfile"):
                listener.exitQfile(self)




    def qfile(self):

        localctx = QuarkParser.QfileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_qfile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.NAMESPACE) | (1 << QuarkParser.PRIMITIVE) | (1 << QuarkParser.INTERFACE) | (1 << QuarkParser.CLASS) | (1 << QuarkParser.ID))) != 0):
                self.state = 66
                localctx._definition = self.definition()
                localctx.definitions.append(localctx._definition)
                self.state = 71
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 72
            self.match(QuarkParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefinitionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.DefinitionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def namespace(self):
            return self.getTypedRuleContext(QuarkParser.NamespaceContext,0)


        def function(self):
            return self.getTypedRuleContext(QuarkParser.FunctionContext,0)


        def primitive(self):
            return self.getTypedRuleContext(QuarkParser.PrimitiveContext,0)


        def qinterface(self):
            return self.getTypedRuleContext(QuarkParser.QinterfaceContext,0)


        def qclass(self):
            return self.getTypedRuleContext(QuarkParser.QclassContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_definition

        def enterRule(self, listener):
            if hasattr(listener, "enterDefinition"):
                listener.enterDefinition(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitDefinition"):
                listener.exitDefinition(self)




    def definition(self):

        localctx = QuarkParser.DefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_definition)
        try:
            self.state = 79
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QuarkParser.NAMESPACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 74
                self.namespace()
                pass
            elif token in [QuarkParser.ID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 75
                self.function()
                pass
            elif token in [QuarkParser.PRIMITIVE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 76
                self.primitive()
                pass
            elif token in [QuarkParser.INTERFACE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 77
                self.qinterface()
                pass
            elif token in [QuarkParser.CLASS]:
                self.enterOuterAlt(localctx, 5)
                self.state = 78
                self.qclass()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NamespaceContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.NamespaceContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._definition = None # DefinitionContext
            self.definitions = list() # of DefinitionContexts

        def NAMESPACE(self):
            return self.getToken(QuarkParser.NAMESPACE, 0)

        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def LBRACE(self):
            return self.getToken(QuarkParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(QuarkParser.RBRACE, 0)

        def definition(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.DefinitionContext)
            else:
                return self.getTypedRuleContext(QuarkParser.DefinitionContext,i)


        def getRuleIndex(self):
            return QuarkParser.RULE_namespace

        def enterRule(self, listener):
            if hasattr(listener, "enterNamespace"):
                listener.enterNamespace(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNamespace"):
                listener.exitNamespace(self)




    def namespace(self):

        localctx = QuarkParser.NamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_namespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.match(QuarkParser.NAMESPACE)
            self.state = 82
            self.name()
            self.state = 83
            self.match(QuarkParser.LBRACE)
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.NAMESPACE) | (1 << QuarkParser.PRIMITIVE) | (1 << QuarkParser.INTERFACE) | (1 << QuarkParser.CLASS) | (1 << QuarkParser.ID))) != 0):
                self.state = 84
                localctx._definition = self.definition()
                localctx.definitions.append(localctx._definition)
                self.state = 89
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 90
            self.match(QuarkParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.FunctionContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._parameter = None # ParameterContext
            self.parameters = list() # of ParameterContexts

        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def LPAREN(self):
            return self.getToken(QuarkParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(QuarkParser.RPAREN, 0)

        def native_body(self):
            return self.getTypedRuleContext(QuarkParser.Native_bodyContext,0)


        def body(self):
            return self.getTypedRuleContext(QuarkParser.BodyContext,0)


        def SEMI(self):
            return self.getToken(QuarkParser.SEMI, 0)

        def qtype(self):
            return self.getTypedRuleContext(QuarkParser.QtypeContext,0)


        def parameter(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ParameterContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ParameterContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(QuarkParser.COMMA)
            else:
                return self.getToken(QuarkParser.COMMA, i)

        def getRuleIndex(self):
            return QuarkParser.RULE_function

        def enterRule(self, listener):
            if hasattr(listener, "enterFunction"):
                listener.enterFunction(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitFunction"):
                listener.exitFunction(self)




    def function(self):

        localctx = QuarkParser.FunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 92
                self.qtype()


            self.state = 95
            self.name()
            self.state = 96
            self.match(QuarkParser.LPAREN)
            self.state = 105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.ID:
                self.state = 97
                localctx._parameter = self.parameter()
                localctx.parameters.append(localctx._parameter)
                self.state = 102
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==QuarkParser.COMMA:
                    self.state = 98
                    self.match(QuarkParser.COMMA)
                    self.state = 99
                    localctx._parameter = self.parameter()
                    localctx.parameters.append(localctx._parameter)
                    self.state = 104
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 107
            self.match(QuarkParser.RPAREN)
            self.state = 111
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QuarkParser.FOR_LANG]:
                self.state = 108
                self.native_body()
                pass
            elif token in [QuarkParser.LBRACE]:
                self.state = 109
                self.body()
                pass
            elif token in [QuarkParser.SEMI]:
                self.state = 110
                self.match(QuarkParser.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.ParameterContext, self).__init__(parent, invokingState)
            self.parser = parser

        def qtype(self):
            return self.getTypedRuleContext(QuarkParser.QtypeContext,0)


        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_parameter

        def enterRule(self, listener):
            if hasattr(listener, "enterParameter"):
                listener.enterParameter(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitParameter"):
                listener.exitParameter(self)




    def parameter(self):

        localctx = QuarkParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.qtype()
            self.state = 114
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimitiveContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.PrimitiveContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._native_body = None # Native_bodyContext
            self.mappings = list() # of Native_bodyContexts
            self._function = None # FunctionContext
            self.definitions = list() # of FunctionContexts

        def PRIMITIVE(self):
            return self.getToken(QuarkParser.PRIMITIVE, 0)

        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def LBRACE(self):
            return self.getToken(QuarkParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(QuarkParser.RBRACE, 0)

        def tparams(self):
            return self.getTypedRuleContext(QuarkParser.TparamsContext,0)


        def native_body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.Native_bodyContext)
            else:
                return self.getTypedRuleContext(QuarkParser.Native_bodyContext,i)


        def function(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.FunctionContext)
            else:
                return self.getTypedRuleContext(QuarkParser.FunctionContext,i)


        def getRuleIndex(self):
            return QuarkParser.RULE_primitive

        def enterRule(self, listener):
            if hasattr(listener, "enterPrimitive"):
                listener.enterPrimitive(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPrimitive"):
                listener.exitPrimitive(self)




    def primitive(self):

        localctx = QuarkParser.PrimitiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_primitive)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self.match(QuarkParser.PRIMITIVE)
            self.state = 117
            self.name()
            self.state = 119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.LT:
                self.state = 118
                self.tparams()


            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==QuarkParser.FOR_LANG:
                self.state = 121
                localctx._native_body = self.native_body()
                localctx.mappings.append(localctx._native_body)
                self.state = 126
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 127
            self.match(QuarkParser.LBRACE)
            self.state = 131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==QuarkParser.ID:
                self.state = 128
                localctx._function = self.function()
                localctx.definitions.append(localctx._function)
                self.state = 133
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 134
            self.match(QuarkParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QinterfaceContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QinterfaceContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._function = None # FunctionContext
            self.definitions = list() # of FunctionContexts

        def INTERFACE(self):
            return self.getToken(QuarkParser.INTERFACE, 0)

        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def LBRACE(self):
            return self.getToken(QuarkParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(QuarkParser.RBRACE, 0)

        def tparams(self):
            return self.getTypedRuleContext(QuarkParser.TparamsContext,0)


        def function(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.FunctionContext)
            else:
                return self.getTypedRuleContext(QuarkParser.FunctionContext,i)


        def getRuleIndex(self):
            return QuarkParser.RULE_qinterface

        def enterRule(self, listener):
            if hasattr(listener, "enterQinterface"):
                listener.enterQinterface(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQinterface"):
                listener.exitQinterface(self)




    def qinterface(self):

        localctx = QuarkParser.QinterfaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_qinterface)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 136
            self.match(QuarkParser.INTERFACE)
            self.state = 137
            self.name()
            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.LT:
                self.state = 138
                self.tparams()


            self.state = 141
            self.match(QuarkParser.LBRACE)
            self.state = 145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==QuarkParser.ID:
                self.state = 142
                localctx._function = self.function()
                localctx.definitions.append(localctx._function)
                self.state = 147
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 148
            self.match(QuarkParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QclassContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QclassContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._qtype = None # QtypeContext
            self.bases = list() # of QtypeContexts
            self._field = None # FieldContext
            self.fields = list() # of FieldContexts
            self._function = None # FunctionContext
            self.methods = list() # of FunctionContexts

        def CLASS(self):
            return self.getToken(QuarkParser.CLASS, 0)

        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def LBRACE(self):
            return self.getToken(QuarkParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(QuarkParser.RBRACE, 0)

        def tparams(self):
            return self.getTypedRuleContext(QuarkParser.TparamsContext,0)


        def EXTENDS(self):
            return self.getToken(QuarkParser.EXTENDS, 0)

        def qtype(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.QtypeContext)
            else:
                return self.getTypedRuleContext(QuarkParser.QtypeContext,i)


        def field(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.FieldContext)
            else:
                return self.getTypedRuleContext(QuarkParser.FieldContext,i)


        def function(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.FunctionContext)
            else:
                return self.getTypedRuleContext(QuarkParser.FunctionContext,i)


        def COMMA(self):
            return self.getToken(QuarkParser.COMMA, 0)

        def getRuleIndex(self):
            return QuarkParser.RULE_qclass

        def enterRule(self, listener):
            if hasattr(listener, "enterQclass"):
                listener.enterQclass(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQclass"):
                listener.exitQclass(self)




    def qclass(self):

        localctx = QuarkParser.QclassContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_qclass)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(QuarkParser.CLASS)
            self.state = 151
            self.name()
            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.LT:
                self.state = 152
                self.tparams()


            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.EXTENDS:
                self.state = 155
                self.match(QuarkParser.EXTENDS)
                self.state = 156
                localctx._qtype = self.qtype()
                localctx.bases.append(localctx._qtype)
                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==QuarkParser.COMMA:
                    self.state = 157
                    self.match(QuarkParser.COMMA)
                    self.state = 158
                    localctx._qtype = self.qtype()
                    localctx.bases.append(localctx._qtype)




            self.state = 163
            self.match(QuarkParser.LBRACE)
            self.state = 168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==QuarkParser.ID:
                self.state = 166
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                if la_ == 1:
                    self.state = 164
                    localctx._field = self.field()
                    localctx.fields.append(localctx._field)
                    pass

                elif la_ == 2:
                    self.state = 165
                    localctx._function = self.function()
                    localctx.methods.append(localctx._function)
                    pass


                self.state = 170
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 171
            self.match(QuarkParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TparamsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.TparamsContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._tparam = None # TparamContext
            self.params = list() # of TparamContexts

        def LT(self):
            return self.getToken(QuarkParser.LT, 0)

        def GT(self):
            return self.getToken(QuarkParser.GT, 0)

        def tparam(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.TparamContext)
            else:
                return self.getTypedRuleContext(QuarkParser.TparamContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(QuarkParser.COMMA)
            else:
                return self.getToken(QuarkParser.COMMA, i)

        def getRuleIndex(self):
            return QuarkParser.RULE_tparams

        def enterRule(self, listener):
            if hasattr(listener, "enterTparams"):
                listener.enterTparams(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTparams"):
                listener.exitTparams(self)




    def tparams(self):

        localctx = QuarkParser.TparamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_tparams)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(QuarkParser.LT)
            self.state = 174
            localctx._tparam = self.tparam()
            localctx.params.append(localctx._tparam)
            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==QuarkParser.COMMA:
                self.state = 175
                self.match(QuarkParser.COMMA)
                self.state = 176
                localctx._tparam = self.tparam()
                localctx.params.append(localctx._tparam)
                self.state = 181
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 182
            self.match(QuarkParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TparamContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.TparamContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.bound = None # QtypeContext

        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def EXTENDS(self):
            return self.getToken(QuarkParser.EXTENDS, 0)

        def qtype(self):
            return self.getTypedRuleContext(QuarkParser.QtypeContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_tparam

        def enterRule(self, listener):
            if hasattr(listener, "enterTparam"):
                listener.enterTparam(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTparam"):
                listener.exitTparam(self)




    def tparam(self):

        localctx = QuarkParser.TparamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_tparam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self.name()
            self.state = 187
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.EXTENDS:
                self.state = 185
                self.match(QuarkParser.EXTENDS)
                self.state = 186
                localctx.bound = self.qtype()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FieldContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.FieldContext, self).__init__(parent, invokingState)
            self.parser = parser

        def qtype(self):
            return self.getTypedRuleContext(QuarkParser.QtypeContext,0)


        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def SEMI(self):
            return self.getToken(QuarkParser.SEMI, 0)

        def EQ(self):
            return self.getToken(QuarkParser.EQ, 0)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_field

        def enterRule(self, listener):
            if hasattr(listener, "enterField"):
                listener.enterField(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitField"):
                listener.exitField(self)




    def field(self):

        localctx = QuarkParser.FieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_field)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self.qtype()
            self.state = 190
            self.name()
            self.state = 193
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.EQ:
                self.state = 191
                self.match(QuarkParser.EQ)
                self.state = 192
                self.expr(0)


            self.state = 195
            self.match(QuarkParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Native_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.Native_bodyContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._ISTRING = None # Token
            self.imports = list() # of Tokens
            self._native_fragment = None # Native_fragmentContext
            self.fragments = list() # of Native_fragmentContexts

        def FOR_LANG(self):
            return self.getToken(QuarkParser.FOR_LANG, 0)

        def LANG(self):
            return self.getToken(QuarkParser.LANG, 0)

        def NATIVE_START(self):
            return self.getToken(QuarkParser.NATIVE_START, 0)

        def NATIVE_RBRACE(self):
            return self.getToken(QuarkParser.NATIVE_RBRACE, 0)

        def IMPORT(self, i=None):
            if i is None:
                return self.getTokens(QuarkParser.IMPORT)
            else:
                return self.getToken(QuarkParser.IMPORT, i)

        def ISTRING(self, i=None):
            if i is None:
                return self.getTokens(QuarkParser.ISTRING)
            else:
                return self.getToken(QuarkParser.ISTRING, i)

        def native_fragment(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.Native_fragmentContext)
            else:
                return self.getTypedRuleContext(QuarkParser.Native_fragmentContext,i)


        def getRuleIndex(self):
            return QuarkParser.RULE_native_body

        def enterRule(self, listener):
            if hasattr(listener, "enterNative_body"):
                listener.enterNative_body(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNative_body"):
                listener.exitNative_body(self)




    def native_body(self):

        localctx = QuarkParser.Native_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_native_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(QuarkParser.FOR_LANG)
            self.state = 198
            self.match(QuarkParser.LANG)
            self.state = 203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==QuarkParser.IMPORT:
                self.state = 199
                self.match(QuarkParser.IMPORT)
                self.state = 200
                localctx._ISTRING = self.match(QuarkParser.ISTRING)
                localctx.imports.append(localctx._ISTRING)
                self.state = 205
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 206
            self.match(QuarkParser.NATIVE_START)
            self.state = 210
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.NATIVE_CODE) | (1 << QuarkParser.QVAR) | (1 << QuarkParser.QEXPR) | (1 << QuarkParser.NATIVE_LBRACE))) != 0):
                self.state = 207
                localctx._native_fragment = self.native_fragment()
                localctx.fragments.append(localctx._native_fragment)
                self.state = 212
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 213
            self.match(QuarkParser.NATIVE_RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Native_fragmentContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.Native_fragmentContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return QuarkParser.RULE_native_fragment

     
        def copyFrom(self, ctx):
            super(QuarkParser.Native_fragmentContext, self).copyFrom(ctx)



    class Native_varContext(Native_fragmentContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.Native_fragmentContext)
            super(QuarkParser.Native_varContext, self).__init__(parser)
            self.copyFrom(ctx)

        def QVAR(self):
            return self.getToken(QuarkParser.QVAR, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterNative_var"):
                listener.enterNative_var(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNative_var"):
                listener.exitNative_var(self)


    class Native_exprContext(Native_fragmentContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.Native_fragmentContext)
            super(QuarkParser.Native_exprContext, self).__init__(parser)
            self.copyFrom(ctx)

        def QEXPR(self):
            return self.getToken(QuarkParser.QEXPR, 0)
        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)

        def RPAREN(self):
            return self.getToken(QuarkParser.RPAREN, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterNative_expr"):
                listener.enterNative_expr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNative_expr"):
                listener.exitNative_expr(self)


    class Native_bracesContext(Native_fragmentContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.Native_fragmentContext)
            super(QuarkParser.Native_bracesContext, self).__init__(parser)
            self._native_fragment = None # Native_fragmentContext
            self.fragments = list() # of Native_fragmentContexts
            self.copyFrom(ctx)

        def NATIVE_LBRACE(self):
            return self.getToken(QuarkParser.NATIVE_LBRACE, 0)
        def NATIVE_RBRACE(self):
            return self.getToken(QuarkParser.NATIVE_RBRACE, 0)
        def native_fragment(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.Native_fragmentContext)
            else:
                return self.getTypedRuleContext(QuarkParser.Native_fragmentContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterNative_braces"):
                listener.enterNative_braces(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNative_braces"):
                listener.exitNative_braces(self)


    class Native_codeContext(Native_fragmentContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.Native_fragmentContext)
            super(QuarkParser.Native_codeContext, self).__init__(parser)
            self.copyFrom(ctx)

        def NATIVE_CODE(self):
            return self.getToken(QuarkParser.NATIVE_CODE, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterNative_code"):
                listener.enterNative_code(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNative_code"):
                listener.exitNative_code(self)



    def native_fragment(self):

        localctx = QuarkParser.Native_fragmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_native_fragment)
        self._la = 0 # Token type
        try:
            self.state = 229
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QuarkParser.NATIVE_CODE]:
                localctx = QuarkParser.Native_codeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 215
                self.match(QuarkParser.NATIVE_CODE)
                pass
            elif token in [QuarkParser.QVAR]:
                localctx = QuarkParser.Native_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 216
                self.match(QuarkParser.QVAR)
                pass
            elif token in [QuarkParser.QEXPR]:
                localctx = QuarkParser.Native_exprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 217
                self.match(QuarkParser.QEXPR)
                self.state = 218
                self.expr(0)
                self.state = 219
                self.match(QuarkParser.RPAREN)
                pass
            elif token in [QuarkParser.NATIVE_LBRACE]:
                localctx = QuarkParser.Native_bracesContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 221
                self.match(QuarkParser.NATIVE_LBRACE)
                self.state = 225
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.NATIVE_CODE) | (1 << QuarkParser.QVAR) | (1 << QuarkParser.QEXPR) | (1 << QuarkParser.NATIVE_LBRACE))) != 0):
                    self.state = 222
                    localctx._native_fragment = self.native_fragment()
                    localctx.fragments.append(localctx._native_fragment)
                    self.state = 227
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 228
                self.match(QuarkParser.NATIVE_RBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.BodyContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._statement = None # StatementContext
            self.statements = list() # of StatementContexts

        def LBRACE(self):
            return self.getToken(QuarkParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(QuarkParser.RBRACE, 0)

        def statement(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.StatementContext)
            else:
                return self.getTypedRuleContext(QuarkParser.StatementContext,i)


        def getRuleIndex(self):
            return QuarkParser.RULE_body

        def enterRule(self, listener):
            if hasattr(listener, "enterBody"):
                listener.enterBody(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBody"):
                listener.exitBody(self)




    def body(self):

        localctx = QuarkParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(QuarkParser.LBRACE)
            self.state = 235
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.NEW) | (1 << QuarkParser.IF) | (1 << QuarkParser.RETURN) | (1 << QuarkParser.WHILE) | (1 << QuarkParser.SWITCH) | (1 << QuarkParser.BREAK) | (1 << QuarkParser.CONTINUE) | (1 << QuarkParser.LBRACE) | (1 << QuarkParser.LPAREN) | (1 << QuarkParser.LBRACK) | (1 << QuarkParser.MINUS) | (1 << QuarkParser.BANG) | (1 << QuarkParser.QMARK) | (1 << QuarkParser.STRING) | (1 << QuarkParser.NUMBER) | (1 << QuarkParser.ID))) != 0):
                self.state = 232
                localctx._statement = self.statement()
                localctx.statements.append(localctx._statement)
                self.state = 237
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 238
            self.match(QuarkParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.StatementContext, self).__init__(parent, invokingState)
            self.parser = parser

        def simple(self):
            return self.getTypedRuleContext(QuarkParser.SimpleContext,0)


        def SEMI(self):
            return self.getToken(QuarkParser.SEMI, 0)

        def compound(self):
            return self.getTypedRuleContext(QuarkParser.CompoundContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_statement

        def enterRule(self, listener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)




    def statement(self):

        localctx = QuarkParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_statement)
        try:
            self.state = 244
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QuarkParser.NEW, QuarkParser.RETURN, QuarkParser.BREAK, QuarkParser.CONTINUE, QuarkParser.LBRACE, QuarkParser.LPAREN, QuarkParser.LBRACK, QuarkParser.MINUS, QuarkParser.BANG, QuarkParser.QMARK, QuarkParser.STRING, QuarkParser.NUMBER, QuarkParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 240
                self.simple()
                self.state = 241
                self.match(QuarkParser.SEMI)
                pass
            elif token in [QuarkParser.IF, QuarkParser.WHILE, QuarkParser.SWITCH]:
                self.enterOuterAlt(localctx, 2)
                self.state = 243
                self.compound()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SimpleContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.SimpleContext, self).__init__(parent, invokingState)
            self.parser = parser

        def local(self):
            return self.getTypedRuleContext(QuarkParser.LocalContext,0)


        def evaluate(self):
            return self.getTypedRuleContext(QuarkParser.EvaluateContext,0)


        def assign(self):
            return self.getTypedRuleContext(QuarkParser.AssignContext,0)


        def qreturn(self):
            return self.getTypedRuleContext(QuarkParser.QreturnContext,0)


        def qbreak(self):
            return self.getTypedRuleContext(QuarkParser.QbreakContext,0)


        def qcontinue(self):
            return self.getTypedRuleContext(QuarkParser.QcontinueContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_simple

        def enterRule(self, listener):
            if hasattr(listener, "enterSimple"):
                listener.enterSimple(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSimple"):
                listener.exitSimple(self)




    def simple(self):

        localctx = QuarkParser.SimpleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_simple)
        try:
            self.state = 252
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 246
                self.local()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 247
                self.evaluate()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 248
                self.assign()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 249
                self.qreturn()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 250
                self.qbreak()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 251
                self.qcontinue()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LocalContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.LocalContext, self).__init__(parent, invokingState)
            self.parser = parser

        def qtype(self):
            return self.getTypedRuleContext(QuarkParser.QtypeContext,0)


        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def EQ(self):
            return self.getToken(QuarkParser.EQ, 0)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_local

        def enterRule(self, listener):
            if hasattr(listener, "enterLocal"):
                listener.enterLocal(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLocal"):
                listener.exitLocal(self)




    def local(self):

        localctx = QuarkParser.LocalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_local)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.qtype()
            self.state = 255
            self.name()
            self.state = 258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.EQ:
                self.state = 256
                self.match(QuarkParser.EQ)
                self.state = 257
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.AssignContext, self).__init__(parent, invokingState)
            self.parser = parser

        def lhs(self):
            return self.getTypedRuleContext(QuarkParser.LhsContext,0)


        def EQ(self):
            return self.getToken(QuarkParser.EQ, 0)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_assign

        def enterRule(self, listener):
            if hasattr(listener, "enterAssign"):
                listener.enterAssign(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAssign"):
                listener.exitAssign(self)




    def assign(self):

        localctx = QuarkParser.AssignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_assign)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.lhs()
            self.state = 261
            self.match(QuarkParser.EQ)
            self.state = 262
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LhsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.LhsContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return QuarkParser.RULE_lhs

     
        def copyFrom(self, ctx):
            super(QuarkParser.LhsContext, self).copyFrom(ctx)



    class SetattrContext(LhsContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.LhsContext)
            super(QuarkParser.SetattrContext, self).__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)

        def DOT(self):
            return self.getToken(QuarkParser.DOT, 0)
        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSetattr"):
                listener.enterSetattr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSetattr"):
                listener.exitSetattr(self)


    class SetvarContext(LhsContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.LhsContext)
            super(QuarkParser.SetvarContext, self).__init__(parser)
            self.copyFrom(ctx)

        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSetvar"):
                listener.enterSetvar(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSetvar"):
                listener.exitSetvar(self)


    class SetindexContext(LhsContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.LhsContext)
            super(QuarkParser.SetindexContext, self).__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)

        def LBRACK(self):
            return self.getToken(QuarkParser.LBRACK, 0)
        def RBRACK(self):
            return self.getToken(QuarkParser.RBRACK, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterSetindex"):
                listener.enterSetindex(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSetindex"):
                listener.exitSetindex(self)



    def lhs(self):

        localctx = QuarkParser.LhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_lhs)
        try:
            self.state = 274
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                localctx = QuarkParser.SetvarContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 264
                self.name()
                pass

            elif la_ == 2:
                localctx = QuarkParser.SetindexContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 265
                self.expr(0)
                self.state = 266
                self.match(QuarkParser.LBRACK)
                self.state = 267
                self.expr(0)
                self.state = 268
                self.match(QuarkParser.RBRACK)
                pass

            elif la_ == 3:
                localctx = QuarkParser.SetattrContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 270
                self.expr(0)
                self.state = 271
                self.match(QuarkParser.DOT)
                self.state = 272
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EvaluateContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.EvaluateContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_evaluate

        def enterRule(self, listener):
            if hasattr(listener, "enterEvaluate"):
                listener.enterEvaluate(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitEvaluate"):
                listener.exitEvaluate(self)




    def evaluate(self):

        localctx = QuarkParser.EvaluateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_evaluate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QbreakContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QbreakContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BREAK(self):
            return self.getToken(QuarkParser.BREAK, 0)

        def getRuleIndex(self):
            return QuarkParser.RULE_qbreak

        def enterRule(self, listener):
            if hasattr(listener, "enterQbreak"):
                listener.enterQbreak(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQbreak"):
                listener.exitQbreak(self)




    def qbreak(self):

        localctx = QuarkParser.QbreakContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_qbreak)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.match(QuarkParser.BREAK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QcontinueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QcontinueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def CONTINUE(self):
            return self.getToken(QuarkParser.CONTINUE, 0)

        def getRuleIndex(self):
            return QuarkParser.RULE_qcontinue

        def enterRule(self, listener):
            if hasattr(listener, "enterQcontinue"):
                listener.enterQcontinue(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQcontinue"):
                listener.exitQcontinue(self)




    def qcontinue(self):

        localctx = QuarkParser.QcontinueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_qcontinue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.match(QuarkParser.CONTINUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QreturnContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QreturnContext, self).__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(QuarkParser.RETURN, 0)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_qreturn

        def enterRule(self, listener):
            if hasattr(listener, "enterQreturn"):
                listener.enterQreturn(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQreturn"):
                listener.exitQreturn(self)




    def qreturn(self):

        localctx = QuarkParser.QreturnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_qreturn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(QuarkParser.RETURN)
            self.state = 284
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.NEW) | (1 << QuarkParser.LBRACE) | (1 << QuarkParser.LPAREN) | (1 << QuarkParser.LBRACK) | (1 << QuarkParser.MINUS) | (1 << QuarkParser.BANG) | (1 << QuarkParser.QMARK) | (1 << QuarkParser.STRING) | (1 << QuarkParser.NUMBER) | (1 << QuarkParser.ID))) != 0):
                self.state = 283
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompoundContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.CompoundContext, self).__init__(parent, invokingState)
            self.parser = parser

        def qif(self):
            return self.getTypedRuleContext(QuarkParser.QifContext,0)


        def qwhile(self):
            return self.getTypedRuleContext(QuarkParser.QwhileContext,0)


        def qswitch(self):
            return self.getTypedRuleContext(QuarkParser.QswitchContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_compound

        def enterRule(self, listener):
            if hasattr(listener, "enterCompound"):
                listener.enterCompound(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCompound"):
                listener.exitCompound(self)




    def compound(self):

        localctx = QuarkParser.CompoundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_compound)
        try:
            self.state = 289
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QuarkParser.IF]:
                self.enterOuterAlt(localctx, 1)
                self.state = 286
                self.qif()
                pass
            elif token in [QuarkParser.WHILE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 287
                self.qwhile()
                pass
            elif token in [QuarkParser.SWITCH]:
                self.enterOuterAlt(localctx, 3)
                self.state = 288
                self.qswitch()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QifContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QifContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.predicate = None # ExprContext
            self.consequence = None # BodyContext
            self.alternative = None # BodyContext

        def IF(self):
            return self.getToken(QuarkParser.IF, 0)

        def LPAREN(self):
            return self.getToken(QuarkParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(QuarkParser.RPAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)


        def body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.BodyContext)
            else:
                return self.getTypedRuleContext(QuarkParser.BodyContext,i)


        def ELSE(self):
            return self.getToken(QuarkParser.ELSE, 0)

        def getRuleIndex(self):
            return QuarkParser.RULE_qif

        def enterRule(self, listener):
            if hasattr(listener, "enterQif"):
                listener.enterQif(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQif"):
                listener.exitQif(self)




    def qif(self):

        localctx = QuarkParser.QifContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_qif)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            self.match(QuarkParser.IF)
            self.state = 292
            self.match(QuarkParser.LPAREN)
            self.state = 293
            localctx.predicate = self.expr(0)
            self.state = 294
            self.match(QuarkParser.RPAREN)
            self.state = 295
            localctx.consequence = self.body()
            self.state = 298
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.ELSE:
                self.state = 296
                self.match(QuarkParser.ELSE)
                self.state = 297
                localctx.alternative = self.body()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QwhileContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QwhileContext, self).__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(QuarkParser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(QuarkParser.LPAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)


        def RPAREN(self):
            return self.getToken(QuarkParser.RPAREN, 0)

        def body(self):
            return self.getTypedRuleContext(QuarkParser.BodyContext,0)


        def getRuleIndex(self):
            return QuarkParser.RULE_qwhile

        def enterRule(self, listener):
            if hasattr(listener, "enterQwhile"):
                listener.enterQwhile(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQwhile"):
                listener.exitQwhile(self)




    def qwhile(self):

        localctx = QuarkParser.QwhileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_qwhile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.match(QuarkParser.WHILE)
            self.state = 301
            self.match(QuarkParser.LPAREN)
            self.state = 302
            self.expr(0)
            self.state = 303
            self.match(QuarkParser.RPAREN)
            self.state = 304
            self.body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QswitchContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QswitchContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SWITCH(self):
            return self.getToken(QuarkParser.SWITCH, 0)

        def LPAREN(self):
            return self.getToken(QuarkParser.LPAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)


        def RPAREN(self):
            return self.getToken(QuarkParser.RPAREN, 0)

        def LBRACE(self):
            return self.getToken(QuarkParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(QuarkParser.RBRACE, 0)

        def qcase(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.QcaseContext)
            else:
                return self.getTypedRuleContext(QuarkParser.QcaseContext,i)


        def getRuleIndex(self):
            return QuarkParser.RULE_qswitch

        def enterRule(self, listener):
            if hasattr(listener, "enterQswitch"):
                listener.enterQswitch(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQswitch"):
                listener.exitQswitch(self)




    def qswitch(self):

        localctx = QuarkParser.QswitchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_qswitch)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            self.match(QuarkParser.SWITCH)
            self.state = 307
            self.match(QuarkParser.LPAREN)
            self.state = 308
            self.expr(0)
            self.state = 309
            self.match(QuarkParser.RPAREN)
            self.state = 310
            self.match(QuarkParser.LBRACE)
            self.state = 312 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 311
                self.qcase()
                self.state = 314 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==QuarkParser.CASE):
                    break

            self.state = 316
            self.match(QuarkParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QcaseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QcaseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(QuarkParser.CASE, 0)

        def exprs(self):
            return self.getTypedRuleContext(QuarkParser.ExprsContext,0)


        def COLON(self):
            return self.getToken(QuarkParser.COLON, 0)

        def statement(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.StatementContext)
            else:
                return self.getTypedRuleContext(QuarkParser.StatementContext,i)


        def getRuleIndex(self):
            return QuarkParser.RULE_qcase

        def enterRule(self, listener):
            if hasattr(listener, "enterQcase"):
                listener.enterQcase(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQcase"):
                listener.exitQcase(self)




    def qcase(self):

        localctx = QuarkParser.QcaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_qcase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.match(QuarkParser.CASE)
            self.state = 319
            self.exprs()
            self.state = 320
            self.match(QuarkParser.COLON)
            self.state = 322 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 321
                self.statement()
                self.state = 324 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.NEW) | (1 << QuarkParser.IF) | (1 << QuarkParser.RETURN) | (1 << QuarkParser.WHILE) | (1 << QuarkParser.SWITCH) | (1 << QuarkParser.BREAK) | (1 << QuarkParser.CONTINUE) | (1 << QuarkParser.LBRACE) | (1 << QuarkParser.LPAREN) | (1 << QuarkParser.LBRACK) | (1 << QuarkParser.MINUS) | (1 << QuarkParser.BANG) | (1 << QuarkParser.QMARK) | (1 << QuarkParser.STRING) | (1 << QuarkParser.NUMBER) | (1 << QuarkParser.ID))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.ExprContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return QuarkParser.RULE_expr

     
        def copyFrom(self, ctx):
            super(QuarkParser.ExprContext, self).copyFrom(ctx)


    class NewContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.NewContext, self).__init__(parser)
            self.copyFrom(ctx)

        def NEW(self):
            return self.getToken(QuarkParser.NEW, 0)
        def qtype(self):
            return self.getTypedRuleContext(QuarkParser.QtypeContext,0)

        def LPAREN(self):
            return self.getToken(QuarkParser.LPAREN, 0)
        def exprs(self):
            return self.getTypedRuleContext(QuarkParser.ExprsContext,0)

        def RPAREN(self):
            return self.getToken(QuarkParser.RPAREN, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterNew"):
                listener.enterNew(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNew"):
                listener.exitNew(self)


    class ComparisonContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.ComparisonContext, self).__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)

        def LT(self):
            return self.getToken(QuarkParser.LT, 0)
        def GT(self):
            return self.getToken(QuarkParser.GT, 0)
        def LE(self):
            return self.getToken(QuarkParser.LE, 0)
        def GE(self):
            return self.getToken(QuarkParser.GE, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterComparison"):
                listener.enterComparison(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitComparison"):
                listener.exitComparison(self)


    class StringContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.StringContext, self).__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(QuarkParser.STRING, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterString"):
                listener.enterString(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitString"):
                listener.exitString(self)


    class Logical_andContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.Logical_andContext, self).__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)

        def AND(self):
            return self.getToken(QuarkParser.AND, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterLogical_and"):
                listener.enterLogical_and(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLogical_and"):
                listener.exitLogical_and(self)


    class VarContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.VarContext, self).__init__(parser)
            self.copyFrom(ctx)

        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterVar"):
                listener.enterVar(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitVar"):
                listener.exitVar(self)


    class IndexContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.IndexContext, self).__init__(parser)
            self.index = None # ExprContext
            self.copyFrom(ctx)

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)

        def LBRACK(self):
            return self.getToken(QuarkParser.LBRACK, 0)
        def RBRACK(self):
            return self.getToken(QuarkParser.RBRACK, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterIndex"):
                listener.enterIndex(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIndex"):
                listener.exitIndex(self)


    class UnaryContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.UnaryContext, self).__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)

        def BANG(self):
            return self.getToken(QuarkParser.BANG, 0)
        def MINUS(self):
            return self.getToken(QuarkParser.MINUS, 0)
        def QMARK(self):
            return self.getToken(QuarkParser.QMARK, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterUnary"):
                listener.enterUnary(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnary"):
                listener.exitUnary(self)


    class ListContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.ListContext, self).__init__(parser)
            self.copyFrom(ctx)

        def LBRACK(self):
            return self.getToken(QuarkParser.LBRACK, 0)
        def exprs(self):
            return self.getTypedRuleContext(QuarkParser.ExprsContext,0)

        def RBRACK(self):
            return self.getToken(QuarkParser.RBRACK, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterList"):
                listener.enterList(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitList"):
                listener.exitList(self)


    class CallContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.CallContext, self).__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)

        def LPAREN(self):
            return self.getToken(QuarkParser.LPAREN, 0)
        def exprs(self):
            return self.getTypedRuleContext(QuarkParser.ExprsContext,0)

        def RPAREN(self):
            return self.getToken(QuarkParser.RPAREN, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterCall"):
                listener.enterCall(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCall"):
                listener.exitCall(self)


    class NumberContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.NumberContext, self).__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(QuarkParser.NUMBER, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterNumber"):
                listener.enterNumber(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNumber"):
                listener.exitNumber(self)


    class Logical_orContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.Logical_orContext, self).__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)

        def OR(self):
            return self.getToken(QuarkParser.OR, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterLogical_or"):
                listener.enterLogical_or(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLogical_or"):
                listener.exitLogical_or(self)


    class ParenContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.ParenContext, self).__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(QuarkParser.LPAREN, 0)
        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)

        def RPAREN(self):
            return self.getToken(QuarkParser.RPAREN, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterParen"):
                listener.enterParen(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitParen"):
                listener.exitParen(self)


    class MultiplicationContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.MultiplicationContext, self).__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)

        def MUL(self):
            return self.getToken(QuarkParser.MUL, 0)
        def DIV(self):
            return self.getToken(QuarkParser.DIV, 0)
        def MOD(self):
            return self.getToken(QuarkParser.MOD, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterMultiplication"):
                listener.enterMultiplication(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitMultiplication"):
                listener.exitMultiplication(self)


    class AttrContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.AttrContext, self).__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(QuarkParser.ExprContext,0)

        def DOT(self):
            return self.getToken(QuarkParser.DOT, 0)
        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterAttr"):
                listener.enterAttr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAttr"):
                listener.exitAttr(self)


    class MapContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.MapContext, self).__init__(parser)
            self._entry = None # EntryContext
            self.entries = list() # of EntryContexts
            self.copyFrom(ctx)

        def LBRACE(self):
            return self.getToken(QuarkParser.LBRACE, 0)
        def RBRACE(self):
            return self.getToken(QuarkParser.RBRACE, 0)
        def entry(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.EntryContext)
            else:
                return self.getTypedRuleContext(QuarkParser.EntryContext,i)

        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(QuarkParser.COMMA)
            else:
                return self.getToken(QuarkParser.COMMA, i)

        def enterRule(self, listener):
            if hasattr(listener, "enterMap"):
                listener.enterMap(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitMap"):
                listener.exitMap(self)


    class EqualityContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.EqualityContext, self).__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)

        def EQL(self):
            return self.getToken(QuarkParser.EQL, 0)
        def NEQ(self):
            return self.getToken(QuarkParser.NEQ, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterEquality"):
                listener.enterEquality(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitEquality"):
                listener.exitEquality(self)


    class AdditionContext(ExprContext):

        def __init__(self, parser, ctx): # actually a QuarkParser.ExprContext)
            super(QuarkParser.AdditionContext, self).__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)

        def PLUS(self):
            return self.getToken(QuarkParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(QuarkParser.MINUS, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterAddition"):
                listener.enterAddition(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAddition"):
                listener.exitAddition(self)



    def expr(self, _p=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = QuarkParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 56
        self.enterRecursionRule(localctx, 56, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QuarkParser.NUMBER]:
                localctx = QuarkParser.NumberContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 327
                self.match(QuarkParser.NUMBER)
                pass
            elif token in [QuarkParser.STRING]:
                localctx = QuarkParser.StringContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 328
                self.match(QuarkParser.STRING)
                pass
            elif token in [QuarkParser.LBRACK]:
                localctx = QuarkParser.ListContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 329
                self.match(QuarkParser.LBRACK)
                self.state = 330
                self.exprs()
                self.state = 331
                self.match(QuarkParser.RBRACK)
                pass
            elif token in [QuarkParser.LBRACE]:
                localctx = QuarkParser.MapContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 333
                self.match(QuarkParser.LBRACE)
                self.state = 342
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.NEW) | (1 << QuarkParser.LBRACE) | (1 << QuarkParser.LPAREN) | (1 << QuarkParser.LBRACK) | (1 << QuarkParser.MINUS) | (1 << QuarkParser.BANG) | (1 << QuarkParser.QMARK) | (1 << QuarkParser.STRING) | (1 << QuarkParser.NUMBER) | (1 << QuarkParser.ID))) != 0):
                    self.state = 334
                    localctx._entry = self.entry()
                    localctx.entries.append(localctx._entry)
                    self.state = 339
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==QuarkParser.COMMA:
                        self.state = 335
                        self.match(QuarkParser.COMMA)
                        self.state = 336
                        localctx._entry = self.entry()
                        localctx.entries.append(localctx._entry)
                        self.state = 341
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 344
                self.match(QuarkParser.RBRACE)
                pass
            elif token in [QuarkParser.ID]:
                localctx = QuarkParser.VarContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 345
                self.name()
                pass
            elif token in [QuarkParser.LPAREN]:
                localctx = QuarkParser.ParenContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 346
                self.match(QuarkParser.LPAREN)
                self.state = 347
                self.expr(0)
                self.state = 348
                self.match(QuarkParser.RPAREN)
                pass
            elif token in [QuarkParser.MINUS, QuarkParser.BANG, QuarkParser.QMARK]:
                localctx = QuarkParser.UnaryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 350
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.MINUS) | (1 << QuarkParser.BANG) | (1 << QuarkParser.QMARK))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 351
                self.expr(8)
                pass
            elif token in [QuarkParser.NEW]:
                localctx = QuarkParser.NewContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 352
                self.match(QuarkParser.NEW)
                self.state = 353
                self.qtype()
                self.state = 354
                self.match(QuarkParser.LPAREN)
                self.state = 355
                self.exprs()
                self.state = 356
                self.match(QuarkParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 393
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 391
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
                    if la_ == 1:
                        localctx = QuarkParser.MultiplicationContext(self, QuarkParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 360
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 361
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.MUL) | (1 << QuarkParser.DIV) | (1 << QuarkParser.MOD))) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 362
                        self.expr(7)
                        pass

                    elif la_ == 2:
                        localctx = QuarkParser.AdditionContext(self, QuarkParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 363
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 364
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==QuarkParser.PLUS or _la==QuarkParser.MINUS):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 365
                        self.expr(5)
                        pass

                    elif la_ == 3:
                        localctx = QuarkParser.ComparisonContext(self, QuarkParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 366
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 367
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.LT) | (1 << QuarkParser.GT) | (1 << QuarkParser.LE) | (1 << QuarkParser.GE))) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 368
                        self.expr(5)
                        pass

                    elif la_ == 4:
                        localctx = QuarkParser.EqualityContext(self, QuarkParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 369
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 370
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==QuarkParser.EQL or _la==QuarkParser.NEQ):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 371
                        self.expr(4)
                        pass

                    elif la_ == 5:
                        localctx = QuarkParser.Logical_andContext(self, QuarkParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 372
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 373
                        localctx.op = self.match(QuarkParser.AND)
                        self.state = 374
                        self.expr(3)
                        pass

                    elif la_ == 6:
                        localctx = QuarkParser.Logical_orContext(self, QuarkParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 375
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 376
                        localctx.op = self.match(QuarkParser.OR)
                        self.state = 377
                        self.expr(2)
                        pass

                    elif la_ == 7:
                        localctx = QuarkParser.AttrContext(self, QuarkParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 378
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 379
                        self.match(QuarkParser.DOT)
                        self.state = 380
                        self.name()
                        pass

                    elif la_ == 8:
                        localctx = QuarkParser.CallContext(self, QuarkParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 381
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 382
                        self.match(QuarkParser.LPAREN)
                        self.state = 383
                        self.exprs()
                        self.state = 384
                        self.match(QuarkParser.RPAREN)
                        pass

                    elif la_ == 9:
                        localctx = QuarkParser.IndexContext(self, QuarkParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 386
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 387
                        self.match(QuarkParser.LBRACK)
                        self.state = 388
                        localctx.index = self.expr(0)
                        self.state = 389
                        self.match(QuarkParser.RBRACK)
                        pass

             
                self.state = 395
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class EntryContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.EntryContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.key = None # ExprContext
            self.value = None # ExprContext

        def COLON(self):
            return self.getToken(QuarkParser.COLON, 0)

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)


        def getRuleIndex(self):
            return QuarkParser.RULE_entry

        def enterRule(self, listener):
            if hasattr(listener, "enterEntry"):
                listener.enterEntry(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitEntry"):
                listener.exitEntry(self)




    def entry(self):

        localctx = QuarkParser.EntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_entry)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            localctx.key = self.expr(0)
            self.state = 397
            self.match(QuarkParser.COLON)
            self.state = 398
            localctx.value = self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.ExprsContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._expr = None # ExprContext
            self.expressions = list() # of ExprContexts

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.ExprContext)
            else:
                return self.getTypedRuleContext(QuarkParser.ExprContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(QuarkParser.COMMA)
            else:
                return self.getToken(QuarkParser.COMMA, i)

        def getRuleIndex(self):
            return QuarkParser.RULE_exprs

        def enterRule(self, listener):
            if hasattr(listener, "enterExprs"):
                listener.enterExprs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitExprs"):
                listener.exitExprs(self)




    def exprs(self):

        localctx = QuarkParser.ExprsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_exprs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 408
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QuarkParser.NEW) | (1 << QuarkParser.LBRACE) | (1 << QuarkParser.LPAREN) | (1 << QuarkParser.LBRACK) | (1 << QuarkParser.MINUS) | (1 << QuarkParser.BANG) | (1 << QuarkParser.QMARK) | (1 << QuarkParser.STRING) | (1 << QuarkParser.NUMBER) | (1 << QuarkParser.ID))) != 0):
                self.state = 400
                localctx._expr = self.expr(0)
                localctx.expressions.append(localctx._expr)
                self.state = 405
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==QuarkParser.COMMA:
                    self.state = 401
                    self.match(QuarkParser.COMMA)
                    self.state = 402
                    localctx._expr = self.expr(0)
                    localctx.expressions.append(localctx._expr)
                    self.state = 407
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QtypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.QtypeContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._qtype = None # QtypeContext
            self.params = list() # of QtypeContexts

        def name(self):
            return self.getTypedRuleContext(QuarkParser.NameContext,0)


        def LT(self):
            return self.getToken(QuarkParser.LT, 0)

        def GT(self):
            return self.getToken(QuarkParser.GT, 0)

        def qtype(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(QuarkParser.QtypeContext)
            else:
                return self.getTypedRuleContext(QuarkParser.QtypeContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(QuarkParser.COMMA)
            else:
                return self.getToken(QuarkParser.COMMA, i)

        def getRuleIndex(self):
            return QuarkParser.RULE_qtype

        def enterRule(self, listener):
            if hasattr(listener, "enterQtype"):
                listener.enterQtype(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQtype"):
                listener.exitQtype(self)




    def qtype(self):

        localctx = QuarkParser.QtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_qtype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.name()
            self.state = 422
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QuarkParser.LT:
                self.state = 411
                self.match(QuarkParser.LT)
                self.state = 412
                localctx._qtype = self.qtype()
                localctx.params.append(localctx._qtype)
                self.state = 417
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==QuarkParser.COMMA:
                    self.state = 413
                    self.match(QuarkParser.COMMA)
                    self.state = 414
                    localctx._qtype = self.qtype()
                    localctx.params.append(localctx._qtype)
                    self.state = 419
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 420
                self.match(QuarkParser.GT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(QuarkParser.NameContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(QuarkParser.ID, 0)

        def getRuleIndex(self):
            return QuarkParser.RULE_name

        def enterRule(self, listener):
            if hasattr(listener, "enterName"):
                listener.enterName(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitName"):
                listener.exitName(self)




    def name(self):

        localctx = QuarkParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 424
            self.match(QuarkParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx, ruleIndex, predIndex):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[28] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx, predIndex):
            if predIndex == 0:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 1)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 9)
         




